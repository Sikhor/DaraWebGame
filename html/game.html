<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="color-scheme" content="dark" />
<meta name="theme-color" content="#05070b" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />



<title>Dara – Game</title>

<link rel="stylesheet" href="css/base.css?v=1707812012">
<link rel="stylesheet" href="css/tablet.css?v=1707812012" media="screen and (max-width: 1024px)">
<link rel="stylesheet" href="css/small.css?v=1707812012"  media="screen and (max-width: 858px)">
<script>
  /*
*/
</script>


</head>

<body>

<div id="rotateHint">
  <div>
    <div style="font-size:20px;margin-bottom:8px;">Bitte Gerät drehen</div>
    <div style="opacity:.75;font-size:14px;">Diese Ansicht ist für Querformat optimiert</div>
  </div>
</div>

<div class="app">

  <!-- TOPBAR -->
  <div class="topbar">
    <div class="title">
      <span>Marina Station: Last Stand</span>
      <span class="badge" id="playerBadge">Player: (loading…)</span>
      <span class="badge" id="waveBadge">Wave: 1</span>
      <span class="badge" id="turnBadge">Turn: 1</span>
    </div>
    <div class="topbarRight">
      <span class="badge" id="gameBadge">Game: 0</span>
    </div>
  </div>

  <!-- MAIN -->
  <div class="main">

    <!-- ENCOUNTER -->
    <div class="panel encounterPanel">
      <div class="panelHeader">
        <span>Encounter</span>
        <div style="display:flex; align-items:center; gap:10px; flex:1; min-width:0;">
          <input id="actionTarget" class="target-input" placeholder="Target" aria-hidden="true" tabindex="-1" />
          <div id="targetPill" class="targetPill" title="">
            <img id="targetPillImg" class="targetPillImg" alt="" />
            <div class="targetPillMain">
              <span id="targetPillText" class="targetPillText">No Target</span>
              <span class="targetPillBadges inline">
                <span id="tpAttack" class="tpBadge">—</span>
                <span id="tpDiff" class="tpBadge">—</span>
              </span>
            </div>
            <button id="targetPillClear" class="targetPillClear" type="button" title="Clear target">×</button>
          </div>

          <div id="infoMarquee" class="infoMarquee" title="">
            <div class="infoTrack">
              <div class="infoInner" id="infoInner">
                <span class="infoText" id="infoTextA"></span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="lanes" id="lanes"></div>
    </div>

    <!-- PARTY -->
    <div class="panel partyPanel">
      <div class="panelHeader">
        <span>Party</span>
        <span class="sub" id="partyCount">Players: 0</span>
        <button id="btnHelp" class="btnTop" type="button" onclick="openHelp()">Help</button>
        <button class="btnTop" id="btnLogout" title="Logout">Logout</button>
      </div>
      <div class="partyList" id="party"></div>
    </div>

  </div>

  <!-- BOTTOM HUD -->
  <div class="hud">
    <div class="hudBar">
      <div class="actions" id="actions"></div>
      <input id="actionMsg" class="chat-input" placeholder="Action / Message…" />
    </div>
  </div>

</div>

<div id="lootToastHost"></div>

<script src="https://cdn.jsdelivr.net/npm/animejs@4.3.5/dist/bundles/anime.umd.min.js"></script>
<script src="./js/game.js"></script>
<script>
/* ======================================================================
   GLOBALS (BEGIN)
   ====================================================================== */
const IMG_BASE = "https://gameinfo.daraempire.com/wp-content/uploads/";
const AVATAR_IMG_BASE = "https://gameinfo.daraempire.com/game-res/avatars";
const BUFF_IMG_BASE= IMG_BASE;
const SOUND_BASE = "https://gameinfo.daraempire.com/game-res/wav";
const HELP_URL="https://gameinfo.daraempire.com/ui/help.html";

const IMG_EXT = ".png";

let PLAYER_SCALE_MAX= 0.65;
let PLAYER_SCALE_MIN_PERCENT= 0.20;

let MOB_SIZE_NORMAL=0.35;
let MOB_SIZE_BOSS= 0.55;
let MOB_SIZE_GROUPBOSS= 0.65;
let MOB_SIZE_RAIDBOSS= 0.75;
let MOB_SIZE_GROUPMOB= 0.40;
let MOB_SIZE_RAIDMOB= 0.55;


let waveOverSoundPlayed= false;
const RANGED_FX_COOLDOWN_MS = 2000; // 2 seconds

let INFO_SPEED_PX_PER_SEC = Number(localStorage.getItem("infoSpeedPxPerSec") || "80");

const deadFx = new Map();
const DEAD_STAY_MS = 2200;

const mobDom = new Map();


/* ======================================================================
   GLOBALS (END)
   ====================================================================== */
const MOB_CONDITIONS = {
  Mezzed: {
    icon: "BuffMezzed.png",
    title: "Mezzed",
    desc: "Cannot act or attack"
  },

  Burned: {
    icon: "BuffBurned.png",   // set to your real file
    title: "Burned",
    desc: "Takes fire damage over time and reduces defense"
  },

  Poisoned: {
    icon: "BuffPoisoned.png",  // set to your real file
    title: "Poisoned",
    desc: "Takes poison damage over time and reduces defense"
  },

  Wounded: {
    icon: "BuffWounded.png",   // optional
    title: "Wounded",
    desc: "Reduced effectiveness and reduces defense"
  },

  Defending: {
    icon: "BuffDefending.png", // optional
    title: "Defending",
    desc: "Reduced damage taken"
  },

  Fleeing: {
    icon: "BuffFleeing.png",   // optional
    title: "Fleeing",
    desc: "Trying to escape"
  },

  Incapacitated: {
    icon: "BuffIncapacitated.png", // optional
    title: "Incapacitated",
    desc: "Cannot act"
  }
};

const CONDITION_PRIORITY = [
  "Mezzed",
  "Burned",
  "Poisoned",
  "Wounded",
  "Fleeing",
  "Defending",
  "Incapacitated"
];

/* ======================================================================
   Mobile special behaviour(BEGIN)
   ====================================================================== */
// Mobile: tap same mob twice to auto-shoot
let _lastMobTapId = null;
let _lastMobTapAt = 0;

function isMobileLike(){
  // coarse pointer = touch devices (phones/tablets)
  return window.matchMedia("(pointer: coarse)").matches;
}

function tryAutoShootOnRepeatTap(mobId){
  if (!isMobileLike()) return;

  const now = performance.now();
  const same = (_lastMobTapId === mobId);
  const fast = (now - _lastMobTapAt) <= 900; // ms window
  _lastMobTapId = mobId;
  _lastMobTapAt = now;

  if (!(same && fast)) return;

  // must have a target set already
  const target = getActionTarget();
  if (!target) return;

  // find shoot button and click it (respects your cooldown + cost checks)
  const shootBtn = document.querySelector(`.action-btn[data-action="shoot"]`);
  if (!shootBtn) return;
  if (shootBtn.classList.contains("cooldown")) return;

  shootBtn.click();
}



/* ======================================================================
   AUTH + STORAGE (BEGIN)
   ====================================================================== */
const LOGIN_PAGE = "index.html";

function getToken() { return localStorage.getItem("sessionToken") || ""; }           // (END getToken)
function getPlayerName() { return localStorage.getItem("playerName") || "unknown player"; }       // (END getPlayerName)
function getGameId(){ return localStorage.getItem("gameId") || "0"; }               // (END getGameId)

/* =====================
   CHARACTER CONTEXT
   ===================== */
function readCharacterFromUrlOnce(){
  const qs = new URLSearchParams(window.location.search);
  const cid = (qs.get("characterId") || "").trim();
  const cname = (qs.get("characterName") || "").trim();

  if (cid) localStorage.setItem("characterId", cid);
  if (cname) localStorage.setItem("characterName", cname);

  // clean URL (optional)
  if (cid || cname){
    const clean = new URL(window.location.href);
    clean.searchParams.delete("characterId");
    clean.searchParams.delete("characterName");
    window.history.replaceState({}, "", clean.toString());
  }
} // (END readCharacterFromUrlOnce)

function getCharacterId(){ return localStorage.getItem("characterId") || ""; }      // (END getCharacterId)
function getCharacterName(){ return localStorage.getItem("characterName") || ""; } // (END getCharacterName)

function requireCharacterOrRedirect(){
  const cid = getCharacterId();
  const cname = getCharacterName();
  if (!cid && !cname){
    window.location.href = LOGIN_PAGE; // back to character select in index.html
  }
} // (END requireCharacterOrRedirect)

function authHeaders(extra = {}) {
  const t = getToken();
  if (!t) return extra;
  return { ...extra, "Authorization": "Bearer " + t };
} // (END authHeaders)

function requireAuthOrRedirect() {
  const t = getToken();
  if (!t) window.location.href = LOGIN_PAGE;
} // (END requireAuthOrRedirect)



async function doLogout() {
  const token = getToken();
  try {
    document.getElementById("btnLogout")?.setAttribute("disabled", "disabled");
    document.getElementById("btnLogoutParty")?.setAttribute("disabled", "disabled");
  } catch (e) {}

  const clearLocal = () => {
    localStorage.removeItem("sessionToken");
    localStorage.removeItem("playerName");
    localStorage.removeItem("gameId");
    localStorage.removeItem("characterId");
    localStorage.removeItem("characterName");
  };

  if (!token) {
    clearLocal();
    window.location.href = LOGIN_PAGE;
    return;
  }
  resetPlayerStatTracking();
  try {
    const res = await fetch(LOGOUT_URL, {
      method: "POST",
      headers: authHeaders({ "Content-Type": "application/json" }),
      body: JSON.stringify({ gameId: String(getGameId()) })
    });

    if (!res.ok) {
      const txt = await res.text().catch(() => "");
      console.warn("Logout not OK:", res.status, txt);
    }
  } catch (e) {
    console.warn("Logout request failed (network):", e);
  } finally {
    clearLocal();
    window.location.href = LOGIN_PAGE;
  }
} // (END doLogout)

document.getElementById("btnLogout").addEventListener("click", doLogout);
document.getElementById("btnLogoutParty")?.addEventListener("click", doLogout);

requireAuthOrRedirect();
readCharacterFromUrlOnce();
requireCharacterOrRedirect();
/* ======================================================================
   AUTH + STORAGE (END)
   ====================================================================== */


/* ======================================================================
   API ENDPOINTS (BEGIN)
   ====================================================================== */
const ACTION_URL = "/api/v001/darawebgame/action";
const STATE_URL  = "/api/v001/darawebgame/state";
const LOGOUT_URL = "/api/v001/darawebgame/auth/logout";
/* ======================================================================
   API ENDPOINTS (END)
   ====================================================================== */


/* ======================================================================
   MEDIA + ACTIONS (BEGIN)
   ====================================================================== */

const ACTION_COSTS = {
  attack:     { res: "en", cost: 10 },
  defend:     { res: "en", cost: 10 },
  fireball:   { res: "mn", cost: 10 },
  heal:       { res: "mn", cost: 10 },
  mezmerize:  { res: "mn", cost: 10 },
  shoot:      { res: "en", cost: 10 },
  usepotion:  { res: null, cost: 0  },
  defuse:     { res: "en", cost: 10 },
  revive:     { res: "mn", cost: 10 },
  evac:       { res: null, cost: 0  }
};

const MEDIA = {
  images: {
    attack: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/JumpAttack-150x150.png",
    defend: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellShieldDefense-150x150.png",
    fireball: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/Fireball-150x150.png",
    mezmerize: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellMezmerize-150x150.png",
    heal: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/PetComeToMe-150x150.png",
    revive: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellBuffConstitution-150x150.png",
    evac: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/ModeratorEvac-150x150.png",
    talk: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/RenameMe-150x150.png",
    usepotion: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/PotionManaExpert-150x150.png",
    shoot: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/Hitscan-150x150.png",
    dead: "https://gameinfo.daraempire.com/wp-content/uploads/Dead.png",
  }
};


const ACTION_SOUNDS = {
  attack:   ["Attack.wav"],
  fireball: ["Fireball.wav"],
  heal:     ["Heal.wav"],
  defend:   ["Defense.wav"],
  explosion:["Explosion1.wav", "Explosion2.wav"],
  explosionsmall:["ExplosionSmall1.wav", "ExplosionSmall2.wav"],
  mezmerize:["Mez.wav"],
  revive:   ["Revive.wav"],
  evac:     ["Evac.wav"],
  defuse:   ["Defuse1.wav", "Defuse2.wav"],
  usepotion:["Potion.wav"],
  shoot:    ["LaserGun1.wav", "LaserGun2.wav", "LaserGun3.wav", "LaserGun4.wav"],
  mobdeath: ["Death_01.wav", "Death_02.wav", "Death_03.wav", "Death_04.wav", "Death_05.wav"],
  spiderdeath: ["MobDeath.wav", "SpiderDeath1.wav","SpiderDeath2.wav"],
  gameover: ["GameOverSciFi.wav"],
  hit:      ["PlayerHit1.wav", "PlayerHit2.wav", "PlayerHit3.wav"],
  loot:     ["Loot1.wav", "Success_1.wav", "Success_2.wav", "Success_3.wav", "Success_4.wav", "Success_5.wav", "Success_6.wav", "Success_7.wav", "Success_8.wav", "Success_9.wav", "Success_10.wav"],
  waveover: ["Pad.wav"],
  wavebegin: ["WaveBegin.wav"]
};

function playSound(key){
  const files = ACTION_SOUNDS[key];
  if(!files || files.length === 0) return;

  // Pick random file
  const randomFile = files[Math.floor(Math.random() * files.length)];

  try{
    const snd = new Audio(SOUND_BASE +"/" + randomFile);
    snd.play().catch(()=>{});
  }catch(e){}
}

function playSoundDeath(atkType)
{
  if (Math.random() < 0.4) return; 
  if(atkType==="Spider"){
    playSound("spiderdeath");
  }else{
    playSound("mobdeath");
  }
}



const ACTIONS = [
  { id: "shoot",      label: "Shoot",    cd: 1  },
  { id: "fireball",   label: "Fireball", cd: 5  },
  { id: "attack",     label: "Attack",   cd: 2  },
  { id: "defend",     label: "Defend",   cd: 3  },
  { id: "heal",       label: "Heal",     cd: 6  },
  { id: "mezmerize",  label: "Mez",      cd: 8  },
  { id: "usepotion",  label: "Potion",   cd: 10 },
  { id: "talk",       label: "Talk",     cd: 1  },
  { id: "revive",     label: "Revive",   cd: 12 },
  { id: "evac",       label: "Evac",     cd: 20 },
];

const actionsEl = document.getElementById("actions");
const actionTargetEl = document.getElementById("actionTarget");
const actionMsgEl = document.getElementById("actionMsg");

const targetPillEl = document.getElementById("targetPill");
const targetPillImgEl = document.getElementById("targetPillImg");
const targetPillTextEl = document.getElementById("targetPillText");
const targetPillClearEl = document.getElementById("targetPillClear");

targetPillClearEl?.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  uiState.selectedMobId = null;
  clearTarget();
  updateEncounterMobs();
});

function getActionTarget(){ return (actionTargetEl.value || "").trim(); } // (END getActionTarget)
function getActionMsg(){ return (actionMsgEl.value || "").trim(); }       // (END getActionMsg)

/* Cooldown state */
const cooldownUntil = new Map();
function nowMs(){ return Date.now(); } // (END nowMs)

function startCooldown(actionId, seconds){
  cooldownUntil.set(actionId, nowMs() + seconds * 1000);
} // (END startCooldown)

function getRemaining(actionId){
  const until = cooldownUntil.get(actionId) || 0;
  return Math.max(0, until - nowMs());
} // (END getRemaining)

function setButtonCooldownUI(btn, remainingMs, totalMs){
  const timeEl = btn.querySelector(".cd-time");
  const fill = btn.querySelector(".cd-fill");

  if (remainingMs <= 0) {
    btn.classList.remove("cooldown");
    if (timeEl) timeEl.textContent = "";
    if (fill) fill.style.transform = "translateY(100%)";
    return;
  }

  btn.classList.add("cooldown");
  const sec = Math.ceil(remainingMs / 1000);
  if (timeEl) timeEl.textContent = String(sec);

  const pct = (remainingMs / totalMs) * 100;
  const y = 100 - pct;
  if (fill) fill.style.transform = `translateY(${y}%)`;
} // (END setButtonCooldownUI)

function buildButtons(){
  actionsEl.innerHTML = "";

  for(const a of ACTIONS){
    const btn = document.createElement("button");
    btn.className = "action-btn";
    btn.type = "button";
    btn.dataset.action = a.id;
    btn.dataset.cd = String(a.cd);

    const img = document.createElement("img");
    img.src = MEDIA.images[a.id] || "";
    img.alt = a.id;
    btn.appendChild(img);

    const count = document.createElement("div");
    count.className = "count";
    btn.appendChild(count);

    const fill = document.createElement("div");
    fill.className = "cd-fill";
    btn.appendChild(fill);

    const overlay = document.createElement("div");
    overlay.className = "cd-overlay";
    overlay.innerHTML = `<div class="cd-time"></div>`;
    btn.appendChild(overlay);

    const tip = document.createElement("div");
    tip.className = "tip";
    tip.textContent = a.label;
    btn.appendChild(tip);

    btn.addEventListener("click", async () => {
      const actionId = a.id;
      const cdSec = a.cd;

      if (getRemaining(actionId) > 0) return;

      if (actionId === "usepotion"){
        const n = getPotionCount ? getPotionCount() : 0;
        if (Number(n) <= 0){
          if (typeof showToast === "function") showToast("No potions left", "error", 1500);
          return;
        }
      }

      if (typeof canPayCost === "function"){
        const pay = canPayCost(actionId);
        if (pay && pay.ok === false){
          const label = (typeof resLabel === "function") ? resLabel(pay.res) : (pay.res || "Resource");
          if (typeof showToast === "function"){
            showToast(`Not enough ${label} for ${actionId.toUpperCase()} (${pay.cur}/${pay.need})`, "error", 1700);
          }
          return;
        }
      }

      playSound(actionId);

      const userName = getPlayerName();
      const characterId = getCharacterId();
      const characterName = getCharacterName();

      if (!userName) {
        console.warn("No playerName in localStorage yet");
        return;
      }
      if (!characterId && !characterName){
        console.warn("No character selected");
        window.location.href = LOGIN_PAGE;
        return;
      }

      startCooldown(actionId, cdSec);
      tickCooldowns();

      const actionTarget = getActionTarget();
      const actionMsg = getActionMsg() || actionId;


      onPlayerDidAction(actionId, actionTarget);

      try {
        const res = await fetch(ACTION_URL, {
          method: "POST",
          headers: authHeaders({ "Content-Type": "application/json" }),
          body: JSON.stringify({
            gameId: String(getGameId()),
            userName,
            characterId,
            characterName,
            actionId,
            actionTarget,
            actionMsg
          })
        });

        if (res.status === 401) doLogout();

        if (!res.ok && typeof showToast === "function"){
          const txt = await res.text().catch(() => "");
          const msg = txt ? txt.slice(0, 140) : `Action failed (${res.status})`;
          showToast(msg, "error", 1800);
        }
      } catch (e) {
        console.error("Action POST failed:", e);
        if (typeof showToast === "function") showToast("Network error: action not sent", "error", 1800);
      }
    });

    actionsEl.appendChild(btn);
  }
} // (END buildButtons)

function tickCooldowns(){
  document.querySelectorAll(".action-btn").forEach(btn => {
    const actionId = btn.dataset.action;

    const totalMs = Number(btn.dataset.cd) * 1000;
    const remainingMs = getRemaining(actionId);
    setButtonCooldownUI(btn, remainingMs, totalMs);

    const countEl = btn.querySelector(".count");
    if (!countEl) return;

    if (actionId === "usepotion"){
      const n = getPotionCount();
      if (n > 0){
        countEl.textContent = String(n);
        countEl.style.display = "flex";
      } else {
        countEl.style.display = "none";
      }
    } else {
      countEl.style.display = "none";
    }
  });
} // (END tickCooldowns)

actionMsgEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    const talkBtn = document.querySelector('.action-btn[data-action="talk"]');
    if (talkBtn) talkBtn.click();
  }
});
/* ======================================================================
   MEDIA + ACTIONS (END)
   ====================================================================== */


/* ======================================================================
   UI STATE + BASIC HELPERS (BEGIN)
   ====================================================================== */
function clamp01(x){ return Math.max(0, Math.min(1, x)); } // (END clamp01)
function pct(v, max){ return max > 0 ? clamp01(v / max) : 0; } // (END pct)

/* Demo state */
let uiState = {
  turn: 1,
  mobs: [],
  party: [],
  selectedMobId: null,
  selectedPartyId: null
};

/* TEST JSON
{
  turn: 1,
  mobs: [
    { id: "MSAgent-Christie", x:0.18, y:0.72, hp:3,  max:6  },
    { id: "Kinora",           x:0.35, y:0.52, hp:3,  max:6  },
    { id: "Insect",           x:0.58, y:0.48, hp:14, max:14 },
    { id: "Spider",           x:0.72, y:0.78, hp:15, max:30 },
    { id: "Kornrex",          x:0.86, y:0.82, hp:25, max:40 },
  ],
  party: [
    { id:"Dara",   hp:7,  hpMax:15, en:40, enMax:40, mn:40, mnMax:40, active:true,  avatarId: "MSAgent-Christie" },
    { id:"Korlan", hp:16, hpMax:20, en:45, enMax:45, mn:45, mnMax:45, active:false, avatarId: "MSAgent-Turnario" },
    { id:"Viper",  hp:11, hpMax:12, en:35, enMax:35, mn:55, mnMax:55, active:false, avatarId: "MSAgent-Soldorn" },
    { id:"Terik",  hp:8,  hpMax:10, en:55, enMax:55, mn:50, mnMax:50, active:false, avatarId: "MSAgent-Tira" },
  ],
  selectedMobId: null,
  selectedPartyId: null
};  
END TESTJSON */

function renderBadges(){
  const p = getPlayerName() || "(not set)";
  const c = getCharacterName() || getCharacterId() || "(no character)";
  document.getElementById("playerBadge").textContent = `Player: ${p} • Char: ${c}`;
  document.getElementById("gameBadge").textContent = "Game: " + getGameId();
  document.getElementById("turnBadge").textContent = "Turn: " + (uiState.turn ?? 1);
  document.getElementById("waveBadge").textContent =
    "Wave: " + (uiState.wave ?? 0) + " | Left: " + (uiState.waveMobsLeft ?? 0);
  document.getElementById("partyCount").textContent = "Players: " + (uiState.party?.length ?? 0);
} // (END renderBadges)

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
} // (END escapeHtml)

function mobImageUrl(mobId){
  if (!mobId) return "";
  const safe = mobId.replace(/[^a-zA-Z0-9_-]/g, "");
  return IMG_BASE + safe + IMG_EXT;
} // (END mobImageUrl)

function playerImageUrl(avatarId){
  if (!avatarId) return "";
  const safe= avatarId;
  // console.log("AvatarUrl: "+AVATAR_IMG_BASE +"/"+ safe);
  return AVATAR_IMG_BASE +"/"+ safe;
} // (END playerImageUrl)
/* ======================================================================
   UI STATE + BASIC HELPERS (END)
   ====================================================================== */


/* ======================================================================
   ENCOUNTER (NO FLICKER) - PERSISTENT DOM (BEGIN)
   ====================================================================== */
function ensureScene(){
  const lanesEl = document.getElementById("lanes");
  let scene = lanesEl.querySelector(".scene");
  if (scene) return scene;

  lanesEl.innerHTML = "";

  scene = document.createElement("div");
  scene.className = "scene";

  const battlefield = document.createElement("div");
  battlefield.className = "battlefield";

  const fog1 = document.createElement("div"); fog1.className = "fog";
  const fog2 = document.createElement("div"); fog2.className = "fog f2";

  scene.appendChild(battlefield);
  scene.appendChild(fog1);
  scene.appendChild(fog2);

  lanesEl.appendChild(scene);
  return scene;
} // (END ensureScene)

function depthScale(y01){
  return MOB_SIZE_NORMAL + clamp01(y01) * MOB_SIZE_NORMAL;
} // (END depthScale)

/* Begin PlayerCard functions ************************************/
/* ======================================================================
   PLAYER CARD IN SCENE (BEGIN)
   ====================================================================== */
let lastKnownMe = null;
let playerDomEntry = null;

function createPlayerDom(){
  const scene = ensureScene();
  const battlefield = scene.querySelector(".battlefield");

  const wrap = document.createElement("div");
  wrap.className = "playerAbs";
  wrap.dataset.id = "__player__";

  const card = document.createElement("div");
  card.className = "mobCard t2"; // reuse same visuals

  const inner = document.createElement("div");
  inner.className = "mob";

  const tag = document.createElement("div");
  tag.className = "targetTag";
  tag.textContent = "You";

  const img = document.createElement("img");
  img.className = "mobImg";
  img.loading = "lazy";

  const fallback = document.createElement("div");
  fallback.className = "avatar";
  fallback.style.display = "none";
  fallback.textContent = "ME";

  const hpBar = document.createElement("div");
  hpBar.className = "hpBar";

  const hpFill = document.createElement("div");
  hpFill.className = "hpFill";
  hpBar.appendChild(hpFill);

  inner.appendChild(tag);
  inner.appendChild(img);
  inner.appendChild(fallback);
  inner.appendChild(hpBar);

  card.appendChild(inner);
  wrap.appendChild(card);
  battlefield.appendChild(wrap);

  img.onerror = () => {
    img.style.display = "none";
    fallback.style.display = "grid";
  };

  // "same functionality": selectable + highlight, but does NOT set mob target
  wrap.onclick = () => {
    uiState.selectedPartyId = "__me__";
    uiState.selectedMobId = null;
    // if you want clicking yourself to clear target:
    // clearTarget();

    updateEncounterMobs();

    try {
      updateEncounterPlayer(getMe());
    } catch(e) {
      console.error("updateEncounterPlayer failed:", e);
    }
    renderParty();
    renderBadges();
  };

  playerDomEntry = { wrap, card, img, hpFill, tag, fallback };
  return playerDomEntry;
}

function calculatePlayerScale(
  data,
  y01,
  {
    minScale = PLAYER_SCALE_MIN_PERCENT,   // never smaller than 10% of base
    maxScale = 1.00,   // full size at 100% HP
    curve    = 1.0     // 1.0 = linear, <1 softer, >1 harsher
  } = {}
){
  // base visual scale (distance + base player size)
  const baseScale = depthScale(y01) * PLAYER_SCALE_MAX;

  if (!data) return baseScale * maxScale;

  const maxHp = Number(data.hpMax || data.maxHP || 1);
  const hp    = Number(data.hp || 0);

  if (maxHp <= 0) return baseScale * maxScale;

  const hpPct = Math.max(0, Math.min(1, hp / maxHp));

  // shape the curve
  const shaped = Math.pow(hpPct, curve);

  // clamp to min/max
  const hpScale =
    minScale + (maxScale - minScale) * shaped;

  return baseScale * hpScale;
}


function updateEncounterPlayer(mePlayer){
  const scene = ensureScene();
  const rect = scene.getBoundingClientRect();
  const w = Math.max(1, rect.width);
  const h = Math.max(1, rect.height);
  const pad = 10;

  // keep last known "me" so card doesn't vanish during early/temporary missing state
  if (mePlayer) lastKnownMe = mePlayer;

  const data = mePlayer || lastKnownMe;

  // always ensure the dom exists (show placeholder if we still have nothing)
  const entry = playerDomEntry || createPlayerDom();

  // bottom-middle inside scene
  const x01 = 0.5;
  const y01 = 0.92;

  const x = pad + x01 * (w - pad*2);
  const y = pad + y01 * (h - pad*2);

  entry.wrap.style.left = `${x}px`;
  entry.wrap.style.top  = `${y}px`;

  const s = calculatePlayerScale(data, y01);;  // player scale playersize
  entry.wrap.style.transform = `translate3d(-50%, -85%, 0) scale(${s})`;

  // If we still don't have data, show a visible placeholder (instead of removing)
  if (!data){
    entry.tag.textContent = "Loading…";
    entry.hpFill.style.width = "100%";
    entry.img.style.display = "none";
    entry.fallback.style.display = "grid";
    entry.fallback.textContent = "…";
    entry.card.classList.remove("selected");
    return;
  }

  // HP
  const max = Number(data.hpMax || data.maxHP || 1);
  const hp  = Number(data.hp || 0);
  const hpPct = max > 0 ? clamp01(hp / max) * 100 : 0;
  entry.hpFill.style.width = `${hpPct}%`;

  // label + image
  const name = String(data.id || "You");
  entry.tag.textContent = name;

  const avatarId = data.avatarId || "";
  const imgSrc = playerImageUrl(avatarId);

  // IMPORTANT: if imgSrc is empty, show fallback (src="" won't trigger onerror reliably)
  if (!imgSrc){
    entry.img.removeAttribute("src");
    entry.img.style.display = "none";
    entry.fallback.style.display = "grid";
  } else if (entry.img.getAttribute("src") !== imgSrc){
    entry.img.style.display = "";
    entry.fallback.style.display = "none";
    entry.img.src = imgSrc;
  }

  entry.fallback.textContent = (name.slice(0,2) || "ME").toUpperCase();

  const selected = (uiState.selectedPartyId === "__me__");
  entry.card.classList.toggle("selected", selected);
}

/* ======================================================================
   PLAYER CARD IN SCENE (END)
   ====================================================================== */


/* End PlayerCard functions **************************************/

/* BEGIN createMobDom(... **************************************/
function createMobDom(mobId, idx){
  const scene = ensureScene();
  const battlefield = scene.querySelector(".battlefield");

  const wrap = document.createElement("div");
  wrap.className = "mobAbs";
  wrap.dataset.id = mobId;


  const card = document.createElement("div");
  card.className = "mobCard " + (["t1","t2","t3","t4"][idx % 4]);

  card.dataset.mobId = mobId;     // so we can select the card fast
  card.classList.add("mob-card"); // optional helper class for querySelector

  // --- Conditions (up to 3 icons, bottom-left) ---
  const condWrap = document.createElement("div");
  condWrap.className = "mob-conditions";
  condWrap.style.display = "none";

  const condImgs = [];
  for (let k = 0; k < 3; k++){
    const im = document.createElement("img");
    im.alt = "condition";
    im.style.display = "none";
    condWrap.appendChild(im);
    condImgs.push(im);
  }

  // Append to card so it overlays the card
  card.appendChild(condWrap);


  /* end conditions */

  const mobInner = document.createElement("div");
  mobInner.className = "mob";

  const targetTag = document.createElement("div");
  targetTag.className = "targetTag";
  targetTag.textContent = mobId;

  const img = document.createElement("img");
  img.className = "mobImg";
  img.loading = "lazy";

  const avatarFallback = document.createElement("div");
  avatarFallback.className = "avatar";
  avatarFallback.style.display = "none";
  avatarFallback.textContent = mobId.slice(0,3);

  const hpBar = document.createElement("div");
  hpBar.className = "hpBar";

  const hpFill = document.createElement("div");
  hpFill.className = "hpFill";
  hpBar.appendChild(hpFill);

  mobInner.appendChild(targetTag);
  mobInner.appendChild(img);
  mobInner.appendChild(avatarFallback);
  mobInner.appendChild(hpBar);

  card.appendChild(mobInner);
  wrap.appendChild(card);
  battlefield.appendChild(wrap);

  img.onerror = () => {
    img.style.display = "none";
    avatarFallback.style.display = "grid";
  };

  wrap.onclick = () => {
    uiState.selectedMobId = mobId;
    uiState.selectedPartyId = null;
    setTargetMobId(mobId);
    updateEncounterMobs();
    tryAutoShootOnRepeatTap(mobId);
  };

  const entry = { wrap, card, img, hpFill, targetTag, avatarFallback, condWrap, condImgs };
  mobDom.set(mobId, entry);
  return entry;
} // (END createMobDom)

function updateEncounterMobs(){
  const scene = ensureScene();
  const rect = scene.getBoundingClientRect();
  const w = Math.max(1, rect.width);
  const h = Math.max(1, rect.height);
  const pad = 10;

  const now = Date.now();

  const alive = (uiState.mobs || []).filter(m => Number(m.hp) > 0);

  const corpses = [];
  for (const [id, fx] of deadFx){
    if (fx.untilMs > now && fx.lastMob) corpses.push(fx.lastMob);
  }

  const mobs = [...alive, ...corpses];
  const seen = new Set();

  mobs.sort((a,b) => Number(a.y ?? 0.5) - Number(b.y ?? 0.5));

  for (let i=0; i<mobs.length; i++){
    const m = mobs[i];
    const id = String(m.id ?? "");
    if (!id) continue;

    seen.add(id);

    let entry = mobDom.get(id);
    if (!entry){
      entry = createMobDom(id, i);
    }

    const x01 = clamp01(Number(m.x ?? 0.5));
    const y01 = clamp01(Number(m.y ?? 0.5));

    const x = pad + x01 * (w - pad*2);
    const y = pad + y01 * (h - pad*2);

    entry.wrap.style.left = `${x}px`;
    entry.wrap.style.top  = `${y}px`;

    const s = depthScale(y01);

    // --- difficulty scaling ---
    const diffKey = normKey(m.difficulty); // uses your helper
    entry.wrap.classList.remove(
      "diff-normal","diff-boss","diff-groupmob","diff-groupboss","diff-raidmob","diff-raidboss",
      "isNonNormal"
    );

    const cls = diffKey ? ("diff-" + diffKey) : "diff-normal";
    entry.wrap.classList.add(cls);

    const isNonNormal = diffKey && diffKey !== "normal";
    entry.wrap.classList.toggle("isNonNormal", !!isNonNormal);

    // choose extra scale (fallback if CSS variable not set)
    let extra = 0;


    if (diffKey === "boss") extra= MOB_SIZE_BOSS;
    if (diffKey === "groupboss") extra= MOB_SIZE_GROUPBOSS;
    if (diffKey === "raidboss") extra = MOB_SIZE_RAIDBOSS;
    if (diffKey === "groupmob") extra = MOB_SIZE_GROUPMOB;
    if (diffKey === "raidmob") extra = MOB_SIZE_RAIDMOB;

    // apply combined scale
    const finalScale = s * (1 + extra);
    entry.wrap.style.transform = `translate3d(-50%, -85%, 0) scale(${finalScale})`;

    entry.wrap.style.zIndex = String(Math.floor(y01 * 1000));

    /* Conditions (up to 3 icons) */
    if (entry.condWrap && entry.condImgs){
      if (getMobConditionsArray(m).length){
        //console.log("[COND]", m.id, "conditions=", m.conditions, "condition=", m.condition);
      }
      const top = getTopConditions(m, 3);

      if (top.length > 0){
        entry.condWrap.style.display = "flex";

        // Tooltip: show all conditions (even if >3)
        const all = getMobConditionsArray(m);
        entry.condWrap.title = all.map(c => {
          const info = conditionInfo(c);
          return `${info.title}: ${info.desc}`;
        }).join("\n");

        for (let k = 0; k < entry.condImgs.length; k++){
          const im = entry.condImgs[k];
          const cname = top[k];

          if (!cname){
            im.style.display = "none";
            im.removeAttribute("src");
            continue;
          }

          const info = conditionInfo(cname);
          const src = BUFF_IMG_BASE + info.icon;

          if (im.getAttribute("src") !== src) im.src = src;
          im.style.display = "";
        }
      } else {
        entry.condWrap.style.display = "none";
        entry.condWrap.title = "";
        for (const im of entry.condImgs){
          im.style.display = "none";
          im.removeAttribute("src");
        }
      }
    }
    /* end Conditions */


    const max = Number(m.max || m.hpMax || 1);
    const hp  = Number(m.hp || 0);
    const hpPct = max > 0 ? clamp01(hp / max) * 100 : 0;
    entry.hpFill.style.width = `${hpPct}%`;

    const label = String(m.displayName || m.avatarId || id);
    entry.targetTag.textContent = label;
    entry.avatarFallback.textContent = label.slice(0,3);

    const isDead = hp <= 0;
    entry.card.classList.toggle("dead", isDead);

    if (isDead && uiState.selectedMobId === id){
      uiState.selectedMobId = null;
    }

    entry.card.classList.toggle("selected", uiState.selectedMobId === id);

    const threat = (uiState.selectedMobId === id) || (hpPct >= 75);
    entry.card.classList.toggle("threat", threat);

    let deathIcon = entry.card.querySelector(".deathIcon");
    if (isDead && !deathIcon){
      deathIcon = document.createElement("div");
      deathIcon.className = "deathIcon";
      deathIcon.innerHTML = `<img src="${MEDIA.images.dead}" alt="dead" />`;
      entry.card.appendChild(deathIcon);
    } else if (!isDead && deathIcon){
      deathIcon.remove();
    }

    const wantSrc = mobImageUrl(m.avatarId || id);
    if (entry.img.getAttribute("src") !== wantSrc){
      entry.img.style.display = "";
      entry.avatarFallback.style.display = "none";
      entry.img.src = wantSrc;
    }
  }

  for (const [id, entry] of mobDom){
    if (!seen.has(id)){
      entry.wrap.remove();
      mobDom.delete(id);
    }
  }

} // (END updateEncounterMobs)
/* ======================================================================
   ENCOUNTER (NO FLICKER) - PERSISTENT DOM (END)
   ====================================================================== */


/* ======================================================================
   PARTY RENDER (BEGIN)
   ====================================================================== */
function barRow(label, percent01, rightText, cls){
  const w = Math.round(percent01 * 100);
  return `
    <div class="pBarRow">
      <div style="font-weight:900;opacity:.9;">${label}</div>
      <div class="pBar ${cls}"><div style="width:${w}%;"></div></div>
      <div class="val">${escapeHtml(rightText)}</div>
    </div>
  `;
} // (END barRow)

const partyDom = new Map();

function ensurePartyRow(p){
  const id = String(p.id || "");
  let entry = partyDom.get(id);
  if (entry) return entry;

  const row = document.createElement("div");
  row.className = "pRow";

  row.innerHTML = `
    <div class="pAvatar">
      <img class="avatarImg" alt="" decoding="async" loading="eager" />
      <div class="avatarText" style="display:none"></div>
    </div>

    <div class="pInfo">
      <div class="pNameLine">
        <span class="name"></span>
        <div style="display:flex; align-items:center; gap:8px;">
          <span class="lvlBadge"></span>
          <span class="meta"></span>
        </div>
      </div>

      <div class="pBars">
        <div class="pBarRow">
          <div style="font-weight:900;opacity:.9;">HP</div>
          <div class="pBar hp"><div class="fill"></div></div>
          <div class="val hpVal"></div>
        </div>

        <div class="pBarRow">
          <div style="font-weight:900;opacity:.9;">EN</div>
          <div class="pBar en"><div class="fill"></div></div>
          <div class="val enVal"></div>
        </div>

        <div class="pBarRow">
          <div style="font-weight:900;opacity:.9;">MN</div>
          <div class="pBar mn"><div class="fill"></div></div>
          <div class="val mnVal"></div>
        </div>

        <div class="pBarRow">
          <div style="font-weight:900;opacity:.9;">XP</div>
          <div class="pBar xp"><div class="fill"></div></div>
          <div class="val xpVal"></div>
        </div>
      </div>
    </div>
  `;

  const img = row.querySelector(".avatarImg");
  const fallback = row.querySelector(".avatarText");

  img.onerror = () => {
    img.style.display = "none";
    fallback.style.display = "grid";
  };

  // click logic same as before
  row.onclick = () => {
    const name = (p.id || "").trim();
    if (!name) return;
    actionTargetEl.value = name;

    uiState.selectedPartyId = p.id;
    uiState.selectedMobId = null;

    updateEncounterMobs();
    renderParty();
    renderBadges();
  };

  entry = {
    row,
    img,
    fallback,
    nameEl: row.querySelector(".name"),
    lvlEl: row.querySelector(".lvlBadge"),
    metaEl: row.querySelector(".meta"),

    hpFill: row.querySelector(".pBar.hp .fill"),
    enFill: row.querySelector(".pBar.en .fill"),
    mnFill: row.querySelector(".pBar.mn .fill"),
    xpFill: row.querySelector(".pBar.xp .fill"),

    hpVal: row.querySelector(".hpVal"),
    enVal: row.querySelector(".enVal"),
    mnVal: row.querySelector(".mnVal"),
    xpVal: row.querySelector(".xpVal"),

    lastImgSrc: ""
  };

  partyDom.set(id, entry);
  document.getElementById("party").appendChild(row);
  return entry;
}

function setFill(el, percent01){
  const w = Math.round(clamp01(Number(percent01) || 0) * 100);
  el.style.width = w + "%";
}

function renderParty(){
  const partyEl = document.getElementById("party");
  const party = uiState.party || [];
  const seen = new Set();

  for (const p of party){
    const id = String(p.id || "");
    if (!id) continue;
    seen.add(id);

    const e = ensurePartyRow(p);

    // selection / damaged classes
    e.row.classList.toggle("selected", uiState.selectedPartyId === p.id);
    e.row.classList.toggle("damaged", !!(uiState._damagedIds && uiState._damagedIds.has(p.id)));

    // text
    e.nameEl.textContent = p.id || "";
    const lvl = Number(p.level ?? 0);
    e.lvlEl.textContent = `Lvl ${lvl}`;
    e.metaEl.textContent = p.active ? "ACTIVE" : "";

    // bars
    const hpP = pct(p.hp, p.hpMax);
    const enP = pct(p.en, p.enMax);
    const mnP = pct(p.mn, p.mnMax);

    const xp  = Number(p.xp ?? 0);
    const xpMax = getXpMax(p) || 100;
    const xpP = xpMax > 0 ? pct(xp, xpMax) : 0;

    setFill(e.hpFill, hpP);
    setFill(e.enFill, enP);
    setFill(e.mnFill, mnP);
    setFill(e.xpFill, xpP);

    e.hpVal.textContent = `${p.hp}/${p.hpMax}`;
    e.enVal.textContent = `${p.en}/${p.enMax}`;
    e.mnVal.textContent = `${p.mn}/${p.mnMax}`;
    e.xpVal.textContent = `${xp}/${xpMax}`;

    // avatar (only update if changed)
    const url = playerImageUrl(p.avatarId);

    // IMPORTANT: avoid setting src="" (causes weird reload behavior)
    if (!url){
      e.img.removeAttribute("src");
      e.img.style.display = "none";
      e.fallback.style.display = "grid";
      e.fallback.textContent = (id.slice(0,2) || "??").toUpperCase();
    } else if (e.lastImgSrc !== url){
      e.lastImgSrc = url;
      e.img.style.display = "";
      e.fallback.style.display = "none";
      e.img.src = url;
      e.fallback.textContent = (id.slice(0,2) || "??").toUpperCase();
    }
  }

  // remove rows not present anymore
  for (const [id, e] of partyDom){
    if (!seen.has(id)){
      e.row.remove();
      partyDom.delete(id);
    }
  }
}
 // (END renderParty)
/* ======================================================================
   PARTY RENDER (END)
   ====================================================================== */


/* ======================================================================
   INFO MSG (BEGIN)
   ====================================================================== */
let lastInfoMsg = "";
function updateInfoMarquee(msg){
  const marquee = document.getElementById("infoMarquee");
  const a = document.getElementById("infoTextA");
  if (!marquee || !a) return;

  const text = String(msg || "").trim();
  const shown = text || "—";

  a.textContent = shown;
  marquee.title = text;

  marquee.classList.remove("scrolling");
  marquee.style.removeProperty("--infoShift");
  marquee.style.removeProperty("--infoDur");

  lastInfoMsg = text;
} // (END updateInfoMarquee)
/* ======================================================================
   INFO MSG (END)
   ====================================================================== */


/* ======================================================================
   DAMAGE + DEATH DETECTION (BEGIN)
   ====================================================================== */
function extractPartyMap(state){
  const map = new Map();
  (state?.party || []).forEach(p => map.set(p.id, p));
  return map;
} // (END extractPartyMap)

function detectPartyDamage(prev, next){
  const prevMap = extractPartyMap(prev);
  const out = [];

  for (const p of (next?.party || [])){
    const id = p.id;
    const prevP = prevMap.get(id);
    if (!prevP) continue;

    const oldHp = Number(prevP.hp ?? 0);
    const newHp = Number(p.hp ?? 0);

    if (newHp < oldHp){
      out.push({ id, dmg: oldHp - newHp, newHp, oldHp });
    }
  }

  return out;
} // (END detectPartyDamage)

function showToast(text, type = "info", ms = 1800){
  const host = document.getElementById("lootToastHost");
  if (!host) return;

  const el = document.createElement("div");
  el.className = "lootToast";

  const t = String(type || "info").toLowerCase();
  if (t === "error") el.classList.add("toastError");
  else if (t === "warn" || t === "warning") el.classList.add("toastWarn");
  else if (t === "success") el.classList.add("toastSuccess");
  else if (t === "loot") el.classList.add("toastLoot");
  else el.classList.add("toastInfo");

  el.textContent = String(text || "—");
  el.style.animationDuration = `${Math.max(300, ms)}ms`;

  host.appendChild(el);
  setTimeout(() => el.remove(), Math.max(500, ms) + 50);
}// (END showToast)

function showLootToast(text){
  showToast(text, "loot", 2800);
  playSound("loot");
} // (END showLootToast)

let lastState = null;
const playedDeaths = new Set();

function extractMobsMap(state){
  const map = new Map();
  (state?.mobs || []).forEach(m => map.set(m.id, m));
  return map;
} // (END extractMobsMap)

function detectMobDeaths(prev, next){
  const prevMap = extractMobsMap(prev);
  const nextMap = extractMobsMap(next);
  const now = Date.now();

  for (const [id, m] of nextMap) {
    if (Number(m.hp) > 0) {
      playedDeaths.delete(id);
      deadFx.delete(id);
    }
  }

  const triggerDeathFx = (id, mobSnapshot) => {
    if (playedDeaths.has(id)) return;
    playedDeaths.add(id);

    playSoundDeath(mobSnapshot.attackType);

    deadFx.set(id, {
      untilMs: now + DEAD_STAY_MS,
      lastMob: { ...mobSnapshot, hp: 0 }
    });

    // showLootToast(`${id} is killed!`);
    markMobDeadAndRemove(id, DEAD_STAY_MS);
  };

  for (const [id, nextMob] of nextMap){
    const prevMob = prevMap.get(id);
    const wasAlive = prevMob ? (Number(prevMob.hp) > 0) : true;
    const isDead   = Number(nextMob.hp) <= 0;
    if (wasAlive && isDead) triggerDeathFx(id, nextMob);
  }

  for (const [id, prevMob] of prevMap){
    const existsNow = nextMap.has(id);
    const wasAlive  = Number(prevMob.hp) > 0;
    if (wasAlive && !existsNow) triggerDeathFx(id, prevMob);
  }

  for (const [id, fx] of deadFx){
    if (now > fx.untilMs) deadFx.delete(id);
  }
} // (END detectMobDeaths)
/* ======================================================================
   DAMAGE + DEATH DETECTION (END)
   ====================================================================== */
/* new death shrinking*/
function markMobDeadAndRemove(mobId, delayMs){
  const card = document.querySelector(`.mob-card[data-mob-id="${CSS.escape(String(mobId))}"]`);
  if (!card) return;
  if (card.dataset.deadStarted === "1") return;

  card.dataset.deadStarted = "1";
  card.classList.add("is-dead");

  window.setTimeout(() => {
    // only remove if it still exists (safe)
    card.remove();
  }, delayMs);
}

/* end new death shrinking*/

document.getElementById("btnHelp")?.addEventListener("click", () => {
  window.open("help.html", "_blank", "noopener");
});

/* ======================================================================
   GAME OVER  (BEGIN)
   ====================================================================== */
function showGameOverOverlay(reason, restartInMs){
  const overlay = document.getElementById("gameOverOverlay");
  const reasonEl = document.getElementById("gameOverReason");
  const secEl = document.getElementById("gameOverSeconds");
  if (!overlay) return;

  reasonEl.textContent = reason || "You lost";
  const sec = Math.max(0, Math.ceil((Number(restartInMs) || 0) / 1000));
  secEl.textContent = String(sec);

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden", "false");
  document.body.classList.add("locked");
} // (END showGameOverOverlay)

function hideGameOverOverlay(){
  const overlay = document.getElementById("gameOverOverlay");
  if (!overlay) return;

  overlay.classList.add("hidden");
  overlay.setAttribute("aria-hidden", "true");
  document.body.classList.remove("locked");
} // (END hideGameOverOverlay)


/* ======================================================================
   GAME OVER (END)
   ====================================================================== */


/* ======================================================================
   RENDER ALL (BEGIN)
   ====================================================================== */
function renderAll(){
  renderBadges();
  updateEncounterPlayer(getMe());
  updateEncounterMobs();
  renderParty();
} // (END renderAll)
/* ======================================================================
   RENDER ALL (END)
   ====================================================================== */


/* ======================================================================
   STATE POLLING (BEGIN)
   ====================================================================== */
async function updateState(){
  try{
    // include character info in state request
    const url = new URL(STATE_URL, window.location.origin);
    const cid = getCharacterId();
    const gid = getGameId();
    if (cid) url.searchParams.set("characterId", cid);
    if (gid) url.searchParams.set("gameId", String(gid));

    const res = await fetch(url.toString(), { headers: authHeaders(), cache: "no-store" });
    if (res.status === 401) { doLogout(); return; }
    if (!res.ok) return;

    const s = await res.json();

    // "me" should be your CHARACTER name (fallback to playerName)
    const myPlayerName = String(getPlayerName() || "").trim();
    const mePlayer = (s.party || []).find(p =>
        String(p.playerName || "").trim() === myPlayerName
    ) || null;

    updateInfoMarquee(s.infoMsg);

 const damages = detectPartyDamage(lastState || uiState, s);

    //const meName = String(mePlayer?.id || "").trim(); // party entry id (character display name)
    const meName = String(s.playerName || "").trim(); // party entry id (character display name)

    if (damages.length > 0 && meName){
      const myHit = damages.find(d => String(d.id) === meName);
      if (myHit){
        const intensity = Math.min(0.45, 0.18 + myHit.dmg / 80);
        playerHitEffect();
        playSound("hit");

        s._damagedIds = new Set([meName]);
        setTimeout(() => {
          if (uiState && uiState._damagedIds){
            uiState._damagedIds = null;
            renderParty();
          }
        }, 450);
      }
    }


    detectMobDeaths(lastState || uiState, s);

    // If party took damage, a mob attacked.
    // Trigger ranged pulse on ranged mobs only.
    if (damages.length > -10) {
      // pick any ranged/combi mob that is alive (simple first version)
      const attacker = (s.mobs || []).find(m =>
        Number(m.hp) > 0 && (m.attackType != "Melee")
      );

      if (attacker) {
        // not used anymore when using projectile
        //handleMobAttack(attacker);
        handleMobAttackProjectile(attacker);
      }
    }

    const keepSelectedMobId   = uiState.selectedMobId;
    const keepSelectedPartyId = uiState.selectedPartyId;

    uiState = s;

    const wasGameOver = String(lastState?.phase || "") === "gameover";
    const isGameOver  = String(s.phase || "") === "gameover";

    if (isGameOver){
      showGameOverOverlay(s.gameOverReason, s.restartInMs);
      if (!wasGameOver) playSound("gameover");
    } else {
      hideGameOverOverlay();
    }

    const wasWave = String(lastState?.phase || "") === "wavecompleted";
    const isWave  = String(s.phase || "") === "wavecompleted";

    if (!isGameOver && isWave){
      if(waveOverSoundPlayed==false){
          playSound("waveover");
          waveOverSoundPlayed=true;
      };
      showWaveOverlay(s.wave, s.restartInMs ?? null);
      if (!wasWave && typeof showToast === "function"){
        showToast(`Wave ${Number(s.wave) || 0} cleared!`, "success", 1800);
      }
    } else {
      if(waveOverSoundPlayed==true){
          playSound("wavebegin");
          waveOverSoundPlayed=false;
      }
      hideWaveOverlay();
    }

    if (s.selectedMobId == null)   uiState.selectedMobId   = keepSelectedMobId;
    if (s.selectedPartyId == null) uiState.selectedPartyId = keepSelectedPartyId;

    lastState = s;

    const tmpPlayer = (s.party || []).find(p =>
        String(p.playerName || "").trim() === s.characterName
    ) || null;

    checkPlayerStatToasts(tmpPlayer);
    CheckTargetClearNeeded();
    renderTargetPillFromId(getActionTarget());

    renderAll();
  } catch(e){
      console.error("updateState crashed:", e);
  }
} // (END updateState)
/* ======================================================================
   STATE POLLING (END)
   ====================================================================== */


/* ======================================================================
   XP,Level, Credits Toasts (BEGIN)
   ====================================================================== */
let lastPlayerStats = null;

function resetPlayerStatTracking() {
  lastPlayerStats = null;
}

function checkPlayerStatToasts(player) {
  if (!player) return;

  if (lastPlayerStats === null) {
    lastPlayerStats = {
      credits: player.credits ?? 0,
      level:   player.level   ?? 0,
      xp:      player.xp      ?? 0,
      potions: player.potions ?? 0
    };
    return;
  }

  function diff(key, positiveMsg, negativeMsg) {
    const prev = lastPlayerStats[key];
    const curr = player[key];

    if (curr === prev) return;

    const delta = curr - prev;
    //console.log("CheckPlayerStats delta check");


    if (delta > 0) {
      if(key!="xp"){
          showLootToast(positiveMsg.replace("{n}", Math.abs(delta)));
      }else{
          showToast(positiveMsg.replace("{n}", Math.abs(delta)), "success", 1500);
      }
    } else {
      showToast(negativeMsg.replace("{n}", Math.abs(delta)), "warning", 1500);
    }

    lastPlayerStats[key] = curr;
  }

  diff("credits", "+{n} Credits", "-{n} Credits");
  diff("xp", "+{n} XP", "-{n} XP");
  diff("potions", "+{n} Potion(s)", "-{n} Potion(s)");

  if (player.level !== lastPlayerStats.level) {
    if (player.level > lastPlayerStats.level) {
      showToast(`Level Up! You are now Level ${player.level}`, "success", 2200);
    } else {
      showToast(`Level changed to ${player.level}`, "warning", 1500);
    }
    lastPlayerStats.level = player.level;
  }
}
/* ======================================================================
   XP,Level, Credits Toasts (END)
   ====================================================================== */


/* ======================================================================
   Wave over Functions (BEGIN)
   ====================================================================== */

function showWaveOverlay(wave, nextInTurns){
  const el = document.getElementById("waveOverlay");
  const title = document.getElementById("waveTitle");
  const sub = document.getElementById("waveSub");
  const numEl = document.getElementById("waveTurnsNum");

  if (!el || !title) return;

  title.textContent = `WAVE ${Number(wave) || 0} CLEARED`;

  if (nextInTurns != null){
    const turnsLeft = Math.max(0, Number(nextInTurns) || 0);

    // optional: keep your old text
    //if (sub) sub.textContent = `Next wave in ~${turnsLeft} turns…`;

    // rolling number
    if (numEl){
      if (_waveTurnsShown === null) {
        numEl.textContent = String(turnsLeft);
      } else if (_waveTurnsShown !== turnsLeft) {
        animateRollingInt(numEl, _waveTurnsShown, turnsLeft, { duration: 520 });
      }
      _waveTurnsShown = turnsLeft;
    }
  } else {
    if (sub) sub.textContent = `Next wave incoming soon…`;
    if (numEl) numEl.textContent = "—";
    _waveTurnsShown = null;
  }

  el.classList.remove("hidden");
  el.setAttribute("aria-hidden", "false");
}

function hideWaveOverlay(){
  const el = document.getElementById("waveOverlay");
  if (!el) return;
  el.classList.add("hidden");
  el.setAttribute("aria-hidden", "true");
  _waveTurnsShown = null;
}

/* ======================================================================
   Wave over Functions (END)
   ====================================================================== */


/* ======================================================================
   Target Pill functions (BEGIN)
   ====================================================================== */
function normKey(s){
  return String(s || "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "");
}

function mapAttackType(s){
  const k = normKey(s);
  switch(k){
    case "ranged": return { text: "Ranged", cls: "tpAtk-ranged" };
    case "melee":  return { text: "Melee", cls: "tpAtk-melee" };
    case "combi":  return { text: "Ranged/Melee", cls: "tpAtk-combi" };
    case "healer": return { text: "Healer", cls: "tpAtk-healer" };
    default:       return { text: (s ? String(s).toLowerCase() : "—"), cls: "" };
  }
}

function mapDifficulty(s){
  const k = normKey(s);
  switch(k){
    case "normal":    return { text: "Normal", cls: "tpDiff-normal" };
    case "boss":      return { text: "Boss", cls: "tpDiff-boss" };
    case "groupmob":  return { text: "Group Mob", cls: "tpDiff-groupmob" };
    case "groupboss": return { text: "Group Boss", cls: "tpDiff-groupboss" };
    case "raidmob":   return { text: "Raid Mob",  cls: "tpDiff-raidmob" };
    case "raidboss":  return { text: "Raid Boss", cls: "tpDiff-raidboss" };
    default:          return { text: (s ? String(s).toLowerCase() : "—"), cls: "" };
  }
}

function setBadge(el, mapping, prefix){
  if (!el) return;
  el.classList.forEach(c => { if (c.startsWith(prefix)) el.classList.remove(c); });
  el.textContent = mapping.text;
  if (mapping.cls) el.classList.add(mapping.cls);
}
/* ======================================================================
   Target Pill functions (END)
   ====================================================================== */
  /* Error Handlers */
  window.addEventListener("error", (e) => {
    console.error("[WINDOW ERROR]", e.message, e.filename, e.lineno, e.colno);
  });
  window.addEventListener("unhandledrejection", (e) => {
    console.error("[PROMISE REJECTION]", e.reason);
  });

/* ======================================================================
   Helper Functions (BEGIN)
   ====================================================================== */
  function getMe(){
    const cid = String(getCharacterId() || "").trim();
    const cname = String(getCharacterName() || "").trim();
    const pname = String(getPlayerName() || "").trim();

    // SAFE debug (won’t crash)
    //console.log("[getMe] pname=", pname, "cname=", cname, "cid=", cid, "partyLen=", (uiState.party||[]).length);


    const party = uiState.party || [];

    // 1) best: match by characterId if your party has it
    if (cid){
      const hit = party.find(p => String(p.characterId || "").trim() === cid);
      if (hit) return hit;
    }

    // 2) match by characterName/id (often same as p.id in your UI)
    if (cname){
      const hit = party.find(p => String(p.id || "").trim() === cname);
      if (hit) return hit;
    }

    // 3) fallback: match by playerName if party has it
    if (pname){
      const hit = party.find(p => String(p.playerName || "").trim() === pname);
      if (hit) return hit;
    }

    return null;
  }


function getResourceValue(player, res){
  if (!player) return 0;
  if (res === "en") return Number(player.en ?? 0);
  if (res === "mn") return Number(player.mn ?? 0);
  return 0;
} // (END getResourceValue)

function resLabel(res){
  return res === "en" ? "Energy" : (res === "mn" ? "Mana" : "Resource");
} // (END resLabel)

function canPayCost(actionId){
  const rule = ACTION_COSTS[actionId];
  if (!rule || !rule.res || Number(rule.cost) <= 0) return { ok:true };

  const me = getMe();
  const cur = getResourceValue(me, rule.res);
  const need = Number(rule.cost);

  return { ok: cur >= need, res: rule.res, cur, need };
} // (END canPayCost)

function getPotionCount(){
  const me = getMe();
  return Number(me?.potions ?? 0);
} // (END getPotionCount)

function getXpMax(p){
  return Number(100);
}

function getMobById(id){
  return (uiState.mobs || []).find(m => String(m.id) === String(id)) || null;
}

function setTargetMobId(mobId){
  const id = String(mobId || "").trim();
  actionTargetEl.value = id;
  actionTargetEl.dataset.targetId = id;
  renderTargetPillFromId(id);
}

function clearTarget(){
  actionTargetEl.value = "";
  delete actionTargetEl.dataset.targetId;
  renderTargetPillFromId("");
}

function renderTargetPillFromId(id){
  const mob = id ? getMobById(id) : null;

  const label = mob ? String(mob.displayName || mob.avatarId || mob.id) : "No Target";
  const imgSrc = mob ? mobImageUrl(mob.avatarId || mob.id) : "";

  const tpAttackEl = document.getElementById("tpAttack");
  const tpDiffEl   = document.getElementById("tpDiff");

  if (mob){
    const atk = mapAttackType(mob.attackType);
    const dif = mapDifficulty(mob.difficulty);
    setBadge(tpAttackEl, atk, "tpAtk-");
    setBadge(tpDiffEl,   dif, "tpDiff-");
  } else {
    setBadge(tpAttackEl, {text:"—", cls:""}, "tpAtk-");
    setBadge(tpDiffEl,   {text:"—", cls:""}, "tpDiff-");
  }

  if (targetPillTextEl) targetPillTextEl.textContent = label;
  if (targetPillEl) targetPillEl.title = mob ? `${label} (${mob.id})` : "No Target";

  if (targetPillImgEl){
    if (imgSrc){
      targetPillImgEl.style.display = "";
      targetPillImgEl.src = imgSrc;
      targetPillImgEl.onerror = () => { targetPillImgEl.style.display = "none"; };
    } else {
      targetPillImgEl.style.display = "none";
      targetPillImgEl.removeAttribute("src");
    }
  }

  if (targetPillClearEl){
    targetPillClearEl.style.display = id ? "" : "none";
  }
}

function CheckTargetClearNeeded(){
  const curTarget = getActionTarget();
  if (!curTarget) return;

  // Only mobs can “vanish / die” in your current target-clear logic
  if (!isMob(curTarget)) return;

  const m = getMobById(curTarget);
  if (!m || Number(m.hp) <= 0){
    clearTarget();
    uiState.selectedMobId = null;
  }
}


function pulseRanged(mobEl){
  if (!mobEl) return;
  mobEl.classList.add("ranged-pulse");
  setTimeout(()=>mobEl.classList.remove("ranged-pulse"), 560);
}

function handleMobAttack(mob){
  if (!mob) return;

  if (mob.attackType === "Ranged" || mob.attackType === "Combi") {
    const mobEl = document.querySelector(`.mobCard[data-mob-id="${mob.id}"]`);
    pulseRanged(mobEl);
  }
}


function spawnRangedProjectile(fromEl){
  if (!fromEl) return;

  const layer = document.getElementById("fxLayer");
  if (!layer) return;

  const a = fromEl.getBoundingClientRect();

  // start: right side of mob
  const x1 = a.left + a.width * 0.75;
  const y1 = a.top  + a.height * 0.35;

  // end of projectile: party side (right edge of scene)
  // const x2 = window.innerWidth * 0.92;
  // const y2 = window.innerHeight * 0.55;
  // end of projectile: somwehere middle bottom
  // const x2 = window.innerWidth * 0.5;
  // const y2 = window.innerHeight * 0.86;
  // end of projectile: center of player card (fallback if not found)
  const pc = getPlayerCardCenter();
  const x2 = pc ? pc.x : (window.innerWidth * 0.5);
  const y2 = pc ? (pc.y - 6) : (window.innerHeight * 0.86);

  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;

  // tracer
  const tracer = document.createElement("div");
  tracer.className = "fx-tracer";
  tracer.style.left = x1 + "px";
  tracer.style.top  = y1 + "px";
  tracer.style.width = dist + "px";
  tracer.style.transform =
    `translate(0,-50%) rotate(${angle}deg)`;
  layer.appendChild(tracer);

  // projectile head
  const shot = document.createElement("div");
  shot.className = "fx-shot";
  shot.style.left = x1 + "px";
  shot.style.top  = y1 + "px";
  layer.appendChild(shot);

  // animate projectile
  shot.animate([
    { left: x1 + "px", top: y1 + "px" },
    { left: x2 + "px", top: y2 + "px" }
  ], { duration: 160, easing: "linear" }).onfinish = () => {
    shot.remove();

    const hit = document.createElement("div");
    hit.className = "fx-hit";
    hit.style.left = x2 + "px";
    hit.style.top  = y2 + "px";
    layer.appendChild(hit);
    setTimeout(()=>hit.remove(), 260);
  };

  // fade tracer
  tracer.animate(
    [{ opacity: 0.9 }, { opacity: 0 }],
    { duration: 160, easing: "linear" }
  ).onfinish = () => tracer.remove();
}

let lastRangedFxAt = 0;
function handleMobAttackProjectile(mob){
  if (!mob) return;
  if(isMezzed(mob)) return;

  // avoid projectile spam
  const now = performance.now();
  if (now - lastRangedFxAt < RANGED_FX_COOLDOWN_MS) return;
  
  lastRangedFxAt = now;

  const atk = normKey(mob.attackType);

  if (atk === "ranged") {
    const mobWrap = document.querySelector(
      `.mobAbs[data-id="${mob.id}"]`
    );
    spawnRangedProjectile(mobWrap);
    playSound("shoot");
  }
  if (atk === "spider") {
    const mobWrap = document.querySelector(
      `.mobAbs[data-id="${mob.id}"]`
    );
    spawnWebProjectile(mobWrap);
    //playSound("shoot");
  }
  if (atk === "insect") {
    const mobWrap = document.querySelector(
      `.mobAbs[data-id="${mob.id}"]`
    );
    spawnAcidSpit(mobWrap);
    //playSound("shoot");
  }


}

function getPlayerCardCenter(){
  // Prefer the actual DOM entry if already created
  const el = (playerDomEntry && playerDomEntry.wrap)
    ? playerDomEntry.wrap
    : document.querySelector(".playerAbs");

  if (!el) return null;

  const r = el.getBoundingClientRect();
  return {
    x: r.left + r.width * 0.5,
    y: r.top  + r.height * 0.5
  };
}


/** conditions functions **********/
function getMobConditionsArray(mob){
  // New format: mob.conditions = ["Mezzed","Burned"]
  const arr = mob?.conditions;
  if (Array.isArray(arr)) return arr.filter(Boolean);

  // Backward compat: mob.condition = "Mezzed"
  const one = mob?.condition;
  if (typeof one === "string" && one && one !== "None") return [one];

  return [];
}

function hasCondition(mob, name){
  const list = getMobConditionsArray(mob);
  const n = String(name || "").trim().toLowerCase();
  return list.some(c => String(c).trim().toLowerCase() === n);
}

// Use this everywhere (shooting, AI, etc.)
function isMezzed(mob){
  return hasCondition(mob, "Mezzed") || hasCondition(mob, "Incapacitated");
}

// returns up to N condition keys, ordered by priority
function getTopConditions(mob, maxCount = 3){
  const list = getMobConditionsArray(mob);
  if (!list.length) return [];

  // Normalize unique list (avoid duplicates like ["Mezzed","Mezzed"])
  const set = new Set(list.map(c => String(c).trim()).filter(Boolean));
  const unique = Array.from(set);

  // Sort by priority first, then alphabetically as fallback
  unique.sort((a,b) => {
    const ia = CONDITION_PRIORITY.findIndex(x => x.toLowerCase() === a.toLowerCase());
    const ib = CONDITION_PRIORITY.findIndex(x => x.toLowerCase() === b.toLowerCase());
    const pa = ia === -1 ? 999 : ia;
    const pb = ib === -1 ? 999 : ib;
    if (pa !== pb) return pa - pb;
    return a.localeCompare(b);
  });

  return unique.slice(0, Math.max(0, maxCount | 0));
}

// maps a condition string to display data
function conditionInfo(condName){
  const key = String(condName || "").trim();
  return MOB_CONDITIONS[key] || {
    icon: "icon-unknown.png",
    title: key || "Unknown",
    desc: "Unknown condition"
  };
}
/* End Condition functions *****************/

function isMob(targetId){
  if (!targetId) return false;
  const id = String(targetId).trim();
  if (!id) return false;

  return (uiState.mobs || []).some(m => String(m.id) === id);
}

function isPlayer(targetId){
  if (!targetId) return false;
  const id = String(targetId).trim();
  if (!id) return false;

  return (uiState.party || []).some(p =>
    String(p.id) === id ||
    String(p.characterName || "") === id ||
    String(p.playerName || "") === id
  );
}


function openHelp(){
  // hook this into your help overlay, modal, or chat later
  window.open(
    HELP_URL,
    "_blank",
    "noopener"
  );
}

/* ======================================================================
   Helper functions (END)
   ====================================================================== */

/* ======================================================================
   FX functions (Begin)
   ====================================================================== */
// Ensure an FX layer exists
function ensureFxLayer(){
  let layer = document.getElementById("fxLayer");
  if (!layer){
    layer = document.createElement("div");
    layer.id = "fxLayer";
    document.body.appendChild(layer);
  }
  return layer;
}

function getElCenter(el){
  const r = el.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2 };
}

// You decide these selectors to match your DOM.
// Common: player card has id="playerAbs" or class ".player-card"
// Mob card has data-mobid="..." or similar.
function getPlayerCardEl(){
  // your player wrapper is .playerAbs (class), not #playerAbs
  return document.querySelector(".playerAbs .mobCard")   // card
      || document.querySelector(".playerAbs");           // fallback wrapper
}

function getMobCardElById(mobId){
  // you store mob id on wrapper: wrap.dataset.id = mobId  -> data-id
  // and on card: card.dataset.mobId = mobId -> data-mob-id
  const id = CSS.escape(String(mobId));
  return document.querySelector(`.mobAbs[data-id="${id}"] .mobCard`) // best: card
      || document.querySelector(`.mobCard[data-mob-id="${id}"]`)     // card fallback
      || document.querySelector(`.mobAbs[data-id="${id}"]`);         // wrapper fallback
}

function fxShoot(fromPt, toPt, opts={}){
  const layer = ensureFxLayer();
  const el = document.createElement("div");
  el.className = "fx-bullet";

  const dx = toPt.x - fromPt.x;
  const dy = toPt.y - fromPt.y;
  const len = Math.hypot(dx, dy);
  const ang = Math.atan2(dy, dx) * 180 / Math.PI;

  el.style.left = `${fromPt.x}px`;
  el.style.top  = `${fromPt.y}px`;
  el.style.width = `${Math.max(12, len)}px`;
  el.style.transform = `translate(0, -50%) rotate(${ang}deg)`;

  layer.appendChild(el);

  // fade out quick
  const dur = opts.duration ?? 180;
  el.animate([{ opacity: 0.95 }, { opacity: 0 }], { duration: dur, easing: "ease-out", fill: "forwards" });

  setTimeout(()=> el.remove(), dur + 30);
}

function fxFireball(fromPt, toPt, opts={}){
  const layer = ensureFxLayer();
  const ball = document.createElement("div");
  ball.className = "fx-fireball";
  layer.appendChild(ball);

  const dx = toPt.x - fromPt.x;
  const dy = toPt.y - fromPt.y;
  const dist = Math.hypot(dx, dy);

  // duration scales a bit with distance but stays reasonable
  const base = opts.duration ?? 520;
  const dur  = Math.min(900, Math.max(380, base + dist * 0.15));

  // rotate the "trail" roughly opposite travel direction
  const ang = Math.atan2(dy, dx) * 180 / Math.PI;

  /* rotate whole fireball INCLUDING Schweif */
  ball.style.transform =
  `translate(${fromPt.x}px, ${fromPt.y}px) translate(-50%, -50%) rotate(${ang}deg)`;
  
  // rotate pseudo trail via inline update on ::after is not possible; use animation transform below:
  // We'll just set a transform on the element itself + let ::after stay aligned visually.

  const anim = ball.animate(
    [
      {
        transform:
          `translate(${fromPt.x}px, ${fromPt.y}px)
          translate(-50%, -50%)
          rotate(${ang}deg)
          scale(0.9)`
      },
      {
        transform:
          `translate(${toPt.x}px, ${toPt.y}px)
          translate(-50%, -50%)
          rotate(${ang}deg)
          scale(1.1)`
      }
    ],

    { duration: dur, easing: "cubic-bezier(.2,.9,.2,1)", fill: "forwards" }
  );

  // small wobble for “magic”
  const wob = ball.animate(
    [
      { filter: "drop-shadow(0 0 10px rgba(255,120,30,0.65))" },
      { filter: "drop-shadow(0 0 16px rgba(255,120,30,0.95))" },
      { filter: "drop-shadow(0 0 10px rgba(255,120,30,0.65))" }
    ],
    { duration: 220, iterations: Math.ceil(dur/220), easing: "ease-in-out" }
  );

  anim.onfinish = () => {
    // impact puff
   spawnFireballImpact(layer, toPt.x, toPt.y);

    wob.cancel();
    ball.remove();
  };
}

function spawnFireballImpact(layer, x, y){
  const host = document.createElement("div");
  host.className = "fx-impact-fireball";
  host.style.left = x + "px";
  host.style.top  = y + "px";

  host.innerHTML = `
    <div class="boom"></div>
    <div class="ring"></div>
    ${Array.from({length: 8}).map((_,i)=>{
      const deg = Math.round((360/8)*i + (Math.random()*18 - 9));
      return `<div class="spark" style="--r:${deg}deg"></div>`;
    }).join("")}
  `;

  layer.appendChild(host);
  setTimeout(()=> host.remove(), 450);
}




function spawnWebProjectile(fromEl){
  if (!fromEl) return;

  const layer = document.getElementById("fxLayer") || ensureFxLayer();
  if (!layer) return;

  const a = fromEl.getBoundingClientRect();

  // start point near mob
  const x1 = a.left + a.width * 0.75;
  const y1 = a.top  + a.height * 0.35;

  // end point = center of player card
  const pc = getPlayerCardCenter();
  const x2 = pc ? pc.x : (window.innerWidth * 0.5);
  const y2 = pc ? pc.y : (window.innerHeight * 0.86);

  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;

  const dur = Math.min(420, Math.max(220, dist * 0.35));

  // strand
  const strand = document.createElement("div");
  strand.className = "fx-webstrand";
  strand.style.left = x1 + "px";
  strand.style.top  = y1 + "px";
  strand.style.width = dist + "px";
  strand.style.transform = `translate(0,-50%) rotate(${angle}deg)`;
  layer.appendChild(strand);

  // web ball
  const ball = document.createElement("div");
  ball.className = "fx-webball";
  ball.style.left = x1 + "px";
  ball.style.top  = y1 + "px";
  layer.appendChild(ball);

  // animate ball
  ball.animate(
    [{ left: x1+"px", top: y1+"px" }, { left: x2+"px", top: y2+"px" }],
    { duration: dur, easing: "cubic-bezier(.2,.8,.2,1)" }
  ).onfinish = () => {
    ball.remove();

    const splat = document.createElement("div");
    splat.className = "fx-websplat";
    splat.style.left = x2 + "px";
    splat.style.top  = y2 + "px";
    layer.appendChild(splat);
    setTimeout(()=> splat.remove(), 560);
  };

  // fade strand out
  strand.animate([{ opacity: 0.85 }, { opacity: 0 }], { duration: dur, easing: "ease-out" })
    .onfinish = () => strand.remove();
}

function spawnAcidSpit(fromEl){
  if (!fromEl) return;
  const layer = document.getElementById("fxLayer") || ensureFxLayer();
  if (!layer) return;

  const a = fromEl.getBoundingClientRect();

  // start near insect mouth area
  const x1 = a.left + a.width * 0.70;
  const y1 = a.top  + a.height * 0.40;

  // end at player center
  const pc = getPlayerCardCenter();
  const x2 = pc ? pc.x : (window.innerWidth * 0.5);
  const y2 = pc ? pc.y : (window.innerHeight * 0.86);

  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;

  const dur = Math.min(520, Math.max(240, dist * 0.45));

  // trail (thin, quick)
  const trail = document.createElement("div");
  trail.className = "fx-acidtrail";
  trail.style.left = x1 + "px";
  trail.style.top  = y1 + "px";
  trail.style.width = dist + "px";
  trail.style.transform = `translate(0,-50%) rotate(${angle}deg)`;
  layer.appendChild(trail);

  // glob
  const glob = document.createElement("div");
  glob.className = "fx-acidglob";
  glob.style.left = x1 + "px";
  glob.style.top  = y1 + "px";
  layer.appendChild(glob);

  // slightly arced travel: midpoint pushed upward a bit
  const mx = (x1 + x2) * 0.5;
  const my = (y1 + y2) * 0.5 - Math.min(60, dist * 0.15);

  glob.animate(
    [
      { transform: "translate(-50%,-50%) scale(0.9)", offset: 0,   left: x1+"px", top: y1+"px" },
      { transform: "translate(-50%,-50%) scale(1.1)", offset: 0.5, left: mx+"px", top: my+"px" },
      { transform: "translate(-50%,-50%) scale(1.0)", offset: 1,   left: x2+"px", top: y2+"px" }
    ],
    { duration: dur, easing: "cubic-bezier(.2,.8,.2,1)" }
  ).onfinish = () => {
    glob.remove();

    const splash = document.createElement("div");
    splash.className = "fx-acidsplash";
    splash.style.left = x2 + "px";
    splash.style.top  = y2 + "px";
    splash.style.transform = `translate(-50%,-50%) rotate(${(Math.random()*18-9).toFixed(1)}deg)`;
    layer.appendChild(splash);
    setTimeout(()=> splash.remove(), 600);
  };

  trail.animate([{ opacity: 0.9 }, { opacity: 0 }], { duration: dur, easing: "ease-out" })
       .onfinish = () => trail.remove();
}





function playActionFx(actionId, targetMobId){
  // do nothing if no target
  if (!targetMobId) return;

  const playerEl = getPlayerCardEl();
  const mobEl    = getMobCardElById(targetMobId);
  if (!playerEl || !mobEl) return;

  const fromPt = getElCenter(playerEl);
  const toPt   = getElCenter(mobEl);

  // Map action -> FX
  switch(String(actionId).toLowerCase()){
    case "shoot":
      fxShoot(toPt, fromPt, { duration: 160 });
      break;

    case "fireball":
      fxFireball(fromPt, toPt, { duration: 520 });
      break;

    // add more later:
    // case "heal":   fxHealBeam(fromPt, toPt); break;
    // case "mezmerize": fxMez(fromPt, toPt); break;

    default:
      // fallback: subtle shoot line
      fxShoot(fromPt, toPt, { duration: 140 });
      break;
  }
}

function onPlayerDidAction(actionId, target){
  // Play local FX immediately (snappy)
  playActionFx(actionId, target);

  // Then do your network call as usual...
  // postActionToServer(actionId, targetMobId);
}

window.testFx = function(){
  const t = getActionTarget();
  console.log("[testFx] target=", t, "playerEl=", !!getPlayerCardEl(), "mobEl=", !!getMobCardElById(t));
  playActionFx("fireball", t);
};

/* ======================================================================
   FX functions (END)
   ====================================================================== */

/* ======================================================================
   KEYBOARD SHORTCUTS (BEGIN)
   ====================================================================== */
const isDesktopInput = window.matchMedia("(pointer: fine)").matches;

document.addEventListener("keydown", (e) => {
  if (!isDesktopInput) return;

  const tag = document.activeElement?.tagName;
  if (tag === "INPUT" || tag === "TEXTAREA") return;

  if (!/^[0-9]$/.test(e.key)) return;

  const index = e.key === "0" ? 9 : (Number(e.key) - 1);
  if (index < 0 || index >= ACTIONS.length) return;

  const actionId = ACTIONS[index].id;
  const btn = document.querySelector(`.action-btn[data-action="${actionId}"]`);
  if (!btn) return;

  e.preventDefault();
  if (btn.classList.contains("cooldown")) return;

  btn.click();
});
/* ======================================================================
   KEYBOARD SHORTCUTS (END)
   ====================================================================== */


/* ======================================================================
   BOOT (RELIABLE)
   ====================================================================== */
let _started = false;
let _stateTimer = null;
let _cdTimer = null;

function startApp(){
  if (_started) return;
  _started = true;

  console.log("[BOOT] startApp()");
  document.getElementById("btnGameOverLogout")?.addEventListener("click", doLogout);

  buildButtons();

  if (_cdTimer) clearInterval(_cdTimer);
  _cdTimer = setInterval(tickCooldowns, 100);
  tickCooldowns();

  // Ensure scene exists immediately, so player card can exist even before state arrives
  ensureScene();

  // Create placeholder player card immediately
  try { updateEncounterPlayer(null); } catch(e){ console.error("updateEncounterPlayer boot failed:", e); }
  try { updateEncounterMobs(); } catch(e){ console.error("updateEncounterMobs boot failed:", e); }
  try { renderParty(); } catch(e){ console.error("renderParty boot failed:", e); }
  try { renderBadges(); } catch(e){ console.error("renderBadges boot failed:", e); }

  if (_stateTimer) clearInterval(_stateTimer);
  _stateTimer = setInterval(updateState, 555);
  updateState();

  window.addEventListener("resize", () => {
    updateEncounterMobs();
    updateEncounterPlayer(getMe()); // keep player positioned on resize too
  });
}

// Normal load
window.addEventListener("DOMContentLoaded", startApp);

// bfcache restore (this is the “works only after refresh” killer sometimes)
window.addEventListener("pageshow", (e) => {
  console.log("[BOOT] pageshow persisted=", e.persisted);
  // On bfcache restore, intervals might be paused/stale depending on browser.
  // Just restart safely:
  _started = false;
  startApp();
});
/* ======================================================================
   END BOOT (RELIABLE)
   ====================================================================== */
</script>

<!-- GAME OVER OVERLAY -->
<div id="gameOverOverlay" class="overlay hidden" aria-hidden="true">
  <div class="overlayCard">
    <div class="overlayTitle">YOU LOST</div>
    <div class="overlayReason" id="gameOverReason">All players are dead</div>

    <div class="overlayTimer">
      Restarting in <span id="gameOverSeconds">3</span>s…
    </div>
    <div style="margin-top:16px; display:flex; justify-content:center; gap:12px;">
      <button id="btnGameOverLogout" class="btnTop">Logout</button>
    </div>

    <div class="overlayHint">Get more help!!!</div>
  </div>
</div>

<!-- WAVE OVER OVERLAY -->
<div id="waveOverlay" class="hidden" aria-hidden="true">
  <div class="waveCard">
    <div class="waveTitle" id="waveTitle">WAVE CLEARED</div>
    <div class="waveSub" id="waveSub">
      <div class="waveTurns">
        Next wave in <span id="waveTurnsNum">—</span> turns…
      </div>
    </div>
  </div>
</div>

<div id="fxLayer" class="fx-layer"></div>
</body>
</html>
