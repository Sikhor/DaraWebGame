<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="color-scheme" content="dark" />
<meta name="theme-color" content="#05070b" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<title>Dara – Game</title>

<style>
  :root{
    --gap: 10px;
    --panel-radius: 12px;
    --border: #2a3340;
    --bg: rgba(10,14,20,0.90);
    --bg2: rgba(0,0,0,0.28);
    --text: #e6e6e6;
    --muted: #9aa6b2;

    --laneLong: rgba(60,120,255,0.18);
    --laneMid:  rgba(255,160,60,0.18);
    --laneMelee:rgba(255,60,60,0.18);

    --slotSize: 58px;
    --topbarH: 50px;

    --partyMaxHMobile: 32vh;

    /* ===== Encounter responsiveness (NEW) ===== */
    --sceneMinH: 420px;     /* desktop default */
    --mobCardSize: 96px;    /* desktop default */
    --mobImgSize: 64px;     /* desktop default */
  }

  html, body { height: 100%; }
  html { background:#05070b; }
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 50% 20%, #121a2a 0%, #05070b 55%);
    color: var(--text);
    font-family: Arial, sans-serif;
    overflow: hidden; /* no page scroll */
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  /* ---------- LAYOUT ---------- */
  .app{
    height: 100%;
    display: grid;
    grid-template-rows: var(--topbarH) 1fr auto; /* <<< WICHTIG */
    gap: var(--gap);
    padding: 10px;
    box-sizing: border-box;
  }

  .topbar{
    height: var(--topbarH);
    border: 1px solid var(--border);
    background: var(--bg);
    border-radius: var(--panel-radius);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 12px;
    box-sizing: border-box;
  }
  .title{
    display:flex;
    align-items:center;
    gap:10px;
    font-weight: 800;
    letter-spacing: 0.5px;
  }
  .badge{
    font-size: 12px;
    color: var(--muted);
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.04);
    padding: 4px 8px;
    border-radius: 999px;
    white-space: nowrap;
  }
  .topbarRight{
    display:flex;
    align-items:center;
    gap:10px;
  }

  .btnTop{
    height: 34px;
    padding: 0 12px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    cursor: pointer;
    font-weight: 800;
    letter-spacing: 0.3px;
  }
  .btnTop:hover { filter: brightness(1.15); }
  .btnTop:active { transform: translateY(1px); }

  .main{
    display: grid;
    grid-template-columns: 1fr 300px; /* encounter | party */
    gap: var(--gap);
    min-height: 0;
  }

  .panel{
    border: 1px solid var(--border);
    background: var(--bg);
    border-radius: var(--panel-radius);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .panelHeader{
    padding: 8px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    display:flex;
    align-items:center;
    justify-content: space-between;
    font-weight: 800;
  }
  .panelHeader .sub{
    font-weight: 600;
    font-size: 12px;
    color: var(--muted);
  }

  /* ---------- ENCOUNTER (legacy grid styles left intact) ---------- */
  .lanes{
    padding: 8px;
    overflow: hidden; /* no scrolling here */
    min-height: 0;
    height: 100%;
  }

  /* legacy lane/slot styles kept (not used by scene, but safe) */
  .lane{
    margin-bottom: 8px;
    border-radius: 10px;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,0.06);
  }
  .lane.long { background: var(--laneLong); }
  .lane.mid  { background: var(--laneMid); }
  .lane.melee{ background: var(--laneMelee); }

  .laneTitle{
    padding: 6px 10px;
    font-size: 12px;
    opacity: 0.9;
    border-bottom: 1px solid rgba(255,255,255,0.08);
    display:flex;
    justify-content: space-between;
    gap: 8px;
  }
  .laneTitle span:last-child{
    color: var(--muted);
    font-weight: 700;
  }

  .laneGrid{
    display: grid;
    grid-template-columns: repeat(var(--slots, 5), var(--slotSize));
    gap: 8px;
    padding: 8px;
    justify-content: start;
  }

  .slot{
    width: var(--slotSize);
    height: var(--slotSize);
    border-radius: 10px;
    background: rgba(0,0,0,0.30);
    border: 1px solid rgba(255,255,255,0.14);
    position: relative;
    cursor: pointer;
    overflow: hidden;
  }
  .slot.empty::after{
    content:"";
    position:absolute;
    inset: 8px;
    border: 1px dashed rgba(255,255,255,0.18);
    border-radius: 8px;
    opacity: 0.75;
  }
  .slot.attackable{ box-shadow: 0 0 0 2px rgba(255,80,80,0.32); }
  .slot.selected{ box-shadow: 0 0 0 2px rgba(120,200,255,0.55); }

  /* =========================
     ENCOUNTER SCENE (Depth + Background)  [UPDATED]
     ========================= */
  .encounterPanel{ min-height: 0; }

  .encounterPanel .lanes{
    padding: 10px;
  }

  .scene{
    position: relative;
    height: 100%;
    min-height: 0;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.08);
    overflow: hidden;

    background-image: url("https://gameinfo.daraempire.com/wp-content/uploads/2024/12/Battle-at-Delco-Towers-2.png");
    background-size: cover;        /* ⬅️ key line */
    background-position: center;   /* center the image */
    background-repeat: no-repeat;  /* don’t tile */
  }

  /* tunnel light cone */
  .scene::before{
    content:"";
    position:absolute;
    inset:-22% -12%;
    background:
      conic-gradient(from 200deg at 50% 35%,
        rgba(140,210,255,0.0) 0deg,
        rgba(140,210,255,0.16) 18deg,
        rgba(140,210,255,0.0) 46deg,
        rgba(140,210,255,0.0) 360deg);
    filter: blur(6px);
    opacity: 0.95;
    pointer-events:none;
    animation: conePulse 5.5s ease-in-out infinite;
  }
  @keyframes conePulse{
    0%,100% { opacity:0.78; transform: translate3d(0,0,0) scale(1); }
    50%     { opacity:1.00; transform: translate3d(0,2px,0) scale(1.01); }
  }

  /* fog layers */
  .fog{
    position:absolute;
    left:-25%; right:-25%;
    height:40%;
    bottom:-10%;
    background:
      radial-gradient(60% 80% at 50% 60%, rgba(200,220,255,0.08) 0%, rgba(0,0,0,0) 65%),
      linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.38) 100%);
    filter: blur(12px);
    opacity:0.92;
    pointer-events:none;
    animation: fogDrift1 12s linear infinite;
  }
  .fog.f2{
    height:52%;
    bottom:-22%;
    opacity:0.62;
    filter: blur(18px);
    animation: fogDrift2 18s linear infinite;
  }
  @keyframes fogDrift1{
    0%   { transform: translate3d(-40px, 0, 0) scale(1.02); }
    50%  { transform: translate3d( 40px,-6px,0) scale(1.04); }
    100% { transform: translate3d(-40px, 0, 0) scale(1.02); }
  }
  @keyframes fogDrift2{
    0%   { transform: translate3d( 60px, 0, 0) scale(1.08); }
    50%  { transform: translate3d(-60px,-10px,0) scale(1.10); }
    100% { transform: translate3d( 60px, 0, 0) scale(1.08); }
  }

  /* Depth layers container */
  .depthLayers{
    position:absolute;
    inset:0;
    display:grid;
    grid-template-rows: 0.2fr 0.5fr 1.5fr; /* back, mid, front */
    padding: 6px 10px 10px;
    pointer-events:none;
  }

  .depthRow{
    display:flex;
    align-items:flex-end;
    justify-content:center;
    gap: 8px;
    position:relative;
  }

  /* row tuning */
  .depthRow.back  { transform: translateY(-4px); opacity:0.65; filter: blur(0.4px); }
  .depthRow.mid   { transform: translateY( 2px); opacity:0.85; filter: blur(0.2px); }
  .depthRow.front { transform: translateY( 8px); opacity:1.00; filter: blur(0px); }


  /* Mob card */
  .mobCardWrap{
    pointer-events:auto;
    transform-origin: 50% 90%;
    transform: translate(var(--tx, 0px), var(--ty, 0px)) scale(var(--s, 1));
  }

  .mobCard{
    width: var(--mobCardSize);
    height: var(--mobCardSize);
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: linear-gradient(180deg, rgba(20,28,40,0.55) 0%, rgba(0,0,0,0.35) 100%);
    box-shadow: 0 14px 28px rgba(0,0,0,0.45);
    position:relative;
    overflow:hidden;
    cursor:pointer;
  }

  /* scale per depth (applies on WRAP for perspective) */
  .depthRow.back  .mobCardWrap{ --s: 0.45; }
  .depthRow.mid   .mobCardWrap{ --s: 0.75; }
  .depthRow.front .mobCardWrap{ --s: 1.08; }

  /* threat glow */
  .mobCard.threat{
    border-color: rgba(120,200,255,0.28);
  }
  .mobCard.threat::after{
    content:"";
    position:absolute; inset:-2px;
    border-radius:14px;
    pointer-events:none;
    box-shadow: 0 0 0 1px rgba(120,200,255,0.35), 0 0 22px rgba(120,200,255,0.16);
    animation: threatPulse 2.2s ease-in-out infinite;
  }
  @keyframes threatPulse{
    0%,100% { opacity:0.55; filter: blur(0px); }
    50%     { opacity:1.00; filter: blur(0.2px); }
  }

  /* “alive” animation (card bob).
     IMPORTANT: we animate mobCard, not the wrap, so wrap keeps its offsets. */
  .mobCard{
    --bobY: 6px;
    --bobT: 3.6s;
    animation: mobBob var(--bobT) ease-in-out infinite;
  }
  .depthRow.back .mobCard{ --bobY: 4px; --bobT: 5.2s; }
  .depthRow.mid  .mobCard{ --bobY: 6px; --bobT: 4.2s; }
  .depthRow.front .mobCard{ --bobY: 7px; --bobT: 3.3s; }

  .mobCard.t1{ animation-delay: -0.3s; }
  .mobCard.t2{ animation-delay: -1.1s; }
  .mobCard.t3{ animation-delay: -2.0s; }
  .mobCard.t4{ animation-delay: -0.6s; }

  @keyframes mobBob{
    0%,100% { transform: translate3d(0,0,0) rotate(-0.15deg); }
    50%     { transform: translate3d(0,var(--bobY),0) rotate(0.20deg); }
  }

  /* put your mob image centered nicely */
  .mobCard .mob{
    position:absolute;
    inset:0;
    display:grid;
    place-items:center;
  }

  /* keep hp bar at bottom like before */
  .mobCard .hpBar{ bottom:4px; }

  /* ===== Selected mob marker (NEW) ===== */
  .mobCard.selected{
    border-color: rgba(120,200,255,0.70) !important;
    box-shadow:
      0 0 0 2px rgba(120,200,255,0.55),
      0 0 22px rgba(120,200,255,0.22),
      0 18px 30px rgba(0,0,0,0.45);
  }
  .mobCard.selected::before{
    content:"";
    position:absolute;
    inset: 6px;
    border-radius: 12px;
    background:
      linear-gradient(#7ad3ff,#7ad3ff) left top / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) left top / 2px 12px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right top / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right top / 2px 12px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) left bottom / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) left bottom / 2px 12px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right bottom / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right bottom / 2px 12px no-repeat;
    opacity: 0.95;
    pointer-events:none;
  }
  .mobCard .targetTag{
    position:absolute;
    top: 6px;
    left: 6px;
    font-size: 10px;
    font-weight: 900;
    letter-spacing: .4px;
    padding: 3px 6px;
    border-radius: 999px;
    background: rgba(120,200,255,0.16);
    border: 1px solid rgba(120,200,255,0.28);
    color: rgba(235,245,255,0.95);
    display:none;
    z-index: 3;
  }
  .mobCard.selected .targetTag{ display:block; }

  /* reduced motion */
  @media (prefers-reduced-motion: reduce){
    .scene::before, .fog, .fog.f2, .mobCard{ animation:none !important; }
  }

  /* ===== Shared mob visuals ===== */
  .mob{
    position:absolute;
    inset:0;
    display:grid;
    place-items:center;
  }
  .avatar{
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.22), rgba(0,0,0,0.35));
    display:grid;
    place-items:center;
    font-weight: 900;
    font-size: 12px;
  }
  .hpBar{
    position:absolute;
    left:10%;
    right:10%;
    bottom:4px;
    height:3px;
    background: rgba(255,255,255,0.14);
    border-radius: 6px;
    overflow:hidden;
  }
  .hpFill{
    height:100%;
    background: linear-gradient(90deg, #3cff9a, #ffd166, #ff4d4d);
  }

  /* IMPORTANT: mobImg now follows variables for scene cards */
  .mobImg{
    width: var(--mobImgSize);
    height: var(--mobImgSize);
    border-radius: 10px;
    object-fit: cover;
    border: 1px solid rgba(255,255,255,0.22);
    box-shadow: 0 0 14px rgba(0,0,0,0.45);
  }

  .avatarImg{
    width: 36px;
    height: 36px;
    border-radius: 10px;
    object-fit: cover;
    border: 1px solid rgba(255,255,255,0.22);
    box-shadow: 0 0 14px rgba(0,0,0,0.45);
  }

  /* ---------- PARTY (ONLY THIS SCROLLS) ---------- */
  .pRow.selected{
    box-shadow: 0 0 0 2px rgba(120,200,255,0.55);
    background: rgba(30,60,120,0.18);
  }

  .partyList{
    padding: 8px;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }

  .pRow{
    display:grid;
    grid-template-columns: 32px 1fr;
    gap: 8px;
    padding: 8px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(0,0,0,0.18);
    margin-bottom: 8px;
  }

  .partyHeaderRight{
    display:flex;
    align-items:center;
    gap:8px;
  }

  .partyLogoutBtn{
    height: 26px;
    padding: 0 10px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    font-size: 12px;
    font-weight: 800;
    cursor: pointer;
  }
  .partyLogoutBtn:active{ transform: translateY(1px); }
  @media (min-width: 1025px){
    .partyLogoutBtn{ display: none; }
  }

  .pAvatar{
    width: 32px;
    height: 32px;
    border-radius: 10px;
    background: rgba(0,0,0,0.45);
    display:grid;
    place-items:center;
    font-weight: 900;
    font-size: 12px;
  }

  .pInfo{
    display:flex;
    flex-direction:column;
    gap: 6px;
    min-width: 0;
  }

  .pNameLine{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 8px;
    font-size: 12px;
    font-weight: 800;
    min-width:0;
  }
  .pNameLine .name{
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .pNameLine .meta{
    font-size: 11px;
    color: var(--muted);
    white-space: nowrap;
    font-weight: 700;
  }

  .pBars{
    display:flex;
    flex-direction:column;
    gap: 6px;
  }

  .pBarRow{
    display:grid;
    grid-template-columns: 26px 1fr 38px;
    gap: 8px;
    align-items:center;
    font-size: 11px;
    color: rgba(255,255,255,0.82);
  }
  .pBar{
    height: 6px;
    background: rgba(255,255,255,0.14);
    border-radius: 6px;
    overflow:hidden;
  }
  .pBar > div { height:100%; width:50%; }
  .pBar.hp > div{ background: linear-gradient(90deg, #3cff9a, #ffd166, #ff4d4d); }
  .pBar.en > div{ background: linear-gradient(90deg, rgba(120,200,255,0.95), rgba(80,150,255,0.85)); }
  .pBar.mn > div{ background: linear-gradient(90deg, rgba(200,140,255,0.95), rgba(120,80,255,0.85)); }

  /* ---------- BOTTOM HUD (10 ACTION BUTTONS + INPUTS) ---------- */
  .hud{
    border: 1px solid var(--border);
    background: var(--bg);
    border-radius: var(--panel-radius);
    padding: 8px;
    box-sizing: border-box;
  }

  .hudBar{
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .target-input{
    width: 120px;
    height: 34px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    padding: 0 10px;
    font-size: 13px;
    flex: 0 0 auto;
  }

  .chat-input{
    flex: 1;
    height: 34px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    padding: 0 14px;
    font-size: 14px;
  }

  .chat-input::placeholder{ opacity: 0.65; }
  .chat-input:focus{
    border-color: rgba(120,170,255,0.55);
    box-shadow: 0 0 0 3px rgba(120,170,255,0.15);
  }

  .actions{
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: 44px;
    gap: 8px;
    justify-content: start;
    flex: 0 0 auto;
  }
  .action-btn{
    width: 44px;
    height: 44px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.25);
    position: relative;

    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;

    overflow: hidden;
    user-select: none;
    cursor: pointer;
  }

  .action-btn img{
    width: 28px;
    height: 28px;
    object-fit: contain;
    pointer-events: none;
  }

  .action-btn .tip{
    position: absolute;
    bottom: 1px;
    left: 3px;
    right: 3px;
    font-size: 9px;
    opacity: 0.8;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    pointer-events: none;
  }

  .action-btn:hover{ filter: brightness(1.15); }
  .action-btn:active{ transform: translateY(1px); }

  /* Cooldown overlay */
  .cd-overlay{
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.55);
    z-index: 2;
  }
  .cd-time{
    font-weight: 900;
    font-size: 14px;
    text-shadow: 0 0 6px rgba(0,0,0,0.9);
  }

  .action-btn.cooldown{
    filter: grayscale(0.6);
    opacity: 0.9;
  }
  .action-btn.cooldown .cd-overlay{ display:flex; }

  .cd-fill{
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.45);
    transform: translateY(100%);
    z-index: 1;
    pointer-events: none;
  }

  /* ---------- MOBILE: stack encounter above party ---------- */
  @media (max-width: 900px){
    :root{
      --gap: 8px;
      --slotSize: 52px;

      /* NEW: mobile scene tuning */
      --sceneMinH: 240px;
      --mobCardSize: 58px;
      --mobImgSize: 36px;
    }

    .app{ padding: 8px; }
    .main{
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
    .partyPanel{
      max-height: var(--partyMaxHMobile);
      min-height: 0;
    }
    
    .hudBar{ flex-wrap: wrap; }
    .chat-input{ min-width: 160px; }

    /* tighter scene */
    .depthLayers{
      display: grid;
      padding: 2px 2px 10px;
      grid-template-rows: 0.2fr 0.5fr 1.5fr; /* back, mid, front */
  }

    .depthRow{ gap: 6px; }
    .fog{ height: 32%; }
    .fog.f2{ height: 40%; }

    /* ensure all 3 lanes fit visually */
    .depthRow.back  { transform: translateY(-6px); }
    .depthRow.mid   { transform: translateY(  4px); }
    .depthRow.front { transform: translateY( 12px); }
    .mobCard.dead .deathIcon img{
      width: 26px;
      height: 26px;
    }
  }

  @media (min-width: 901px){
    :root{
      /* NEW: PC scene tuning */
      --sceneMinH: 520px;
      --mobCardSize: 128px;
      --mobImgSize: 96px;
    }
  }

  @media (max-width: 420px){
    :root{ --slotSize: 48px; }
    .actions{ grid-template-columns: repeat(5, 40px); }
    .action-btn{ width: 40px; height: 40px; }
    .action-btn img{ width: 24px; height: 24px; }
  }

  #rotateHint{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    z-index: 99999;
    display: none;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: #fff;
    font-weight: 800;
    letter-spacing: 0.5px;
  }

  @media (orientation: portrait){
    #rotateHint{ display: flex; }
  }

  /* ===== ONE Landscape Mobile Block (merge all here) ===== */
  @media (orientation: landscape) and (max-width: 1024px){
    :root{
      --gap: 6px;
      --slotSize: 40px;

      /* NEW: keep scene compact in landscape on mobile/tablet */
      --sceneMinH: 220px;
      --mobCardSize: 58px;
      --mobImgSize: 32px;
    }

    .topbar{ display: none; }

    .app{
      grid-template-rows: 1fr auto; /* main | hud */
    }

    .main{
      grid-template-columns: 400px 200px;
      grid-template-rows: 1fr;
      gap: 6px;
    }

    .partyPanel{ max-height: none; }

    .panelHeader{
      padding: 6px 10px;
      font-size: 13px;
    }
    .panelHeader .sub{ font-size: 11px; }

    .lanes{ padding: 6px; }

    .lane{ margin-bottom: 6px; border-radius: 9px; position: relative; padding-top: 18px; }
    .laneTitle{ display: none; }
    .lane{ padding-top: 0; }
    .laneGrid{ padding: 6px; gap: 6px; }

    .avatar{ width: 26px; height: 26px; font-size: 9px; }
    .hpBar{ left: 10%; right: 10%; bottom: 4px; height: 4px; }

    .hudBar{ flex-wrap: nowrap; }
    .chat-input{ min-width: 0; height: 32px; font-size: 13px; }
    .target-input{ width: 95px; height: 32px; font-size: 12px; }

    .actions{ grid-auto-columns: 40px; gap: 6px; }
    .action-btn{ width: 40px; height: 40px; }
    .action-btn img{ width: 24px; height: 24px; }

    /* tighter scene */
    .depthLayers{
      display: grid;
      grid-template-rows: 0.2fr 0.5fr 1.5fr; /* back, mid, front */
    }
    .depthRow{ gap: 6px; }
    .fog{ height: 30%; }
    .fog.f2{ height: 36%; }

    .depthRow.back  { transform: translateY(-6px); }
    .depthRow.mid   { transform: translateY(  3px); }
    .depthRow.front { transform: translateY( 10px); }
  }

  /* ===== GAME OVER OVERLAY ===== */
.overlay{
  position: fixed;
  inset: 0;
  z-index: 99998; /* under rotateHint (99999), above everything else */
  display: grid;
  place-items: center;
  background: rgba(0,0,0,0.72);
  backdrop-filter: blur(6px);
}

.overlay.hidden{ display:none; }

.overlayCard{
  width: min(520px, 92vw);
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.16);
  background: linear-gradient(180deg, rgba(25,10,12,0.86) 0%, rgba(0,0,0,0.55) 100%);
  box-shadow: 0 24px 60px rgba(0,0,0,0.65);
  padding: 18px 18px 16px;
  text-align: center;
}

.overlayTitle{
  font-weight: 900;
  letter-spacing: 1px;
  font-size: 34px;
  text-transform: uppercase;
  text-shadow: 0 0 22px rgba(255,70,70,0.25);
}

.overlayReason{
  margin-top: 6px;
  color: rgba(255,255,255,0.85);
  font-size: 14px;
}

.overlayTimer{
  margin-top: 14px;
  font-weight: 900;
  font-size: 16px;
  color: rgba(255,255,255,0.92);
}

.overlayHint{
  margin-top: 10px;
  font-size: 12px;
  color: rgba(255,255,255,0.62);
}

#btnGameOverLogout{
  background: linear-gradient(180deg, rgba(120,20,20,0.9), rgba(60,10,10,0.9));
  border-color: rgba(255,80,80,0.5);
}
#btnGameOverLogout:hover{
  filter: brightness(1.15);
}

/* lock the UI feel while overlay is up */
body.locked .action-btn,
body.locked .chat-input,
body.locked .target-input{
  pointer-events: none;
  filter: grayscale(0.4);
  opacity: 0.85;
}

/* ===== DAMAGE FEEDBACK ===== */
#hitFlash{
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 99997;
  opacity: 0;

  /* MUCH softer: darker vignette instead of red blast */
  background:
    radial-gradient(
      70% 55% at 50% 40%,
      rgba(180,60,60,0.12),
      rgba(0,0,0,0) 65%
    ),
    linear-gradient(
      180deg,
      rgba(120,30,30,0.06),
      rgba(0,0,0,0)
    );

  transition: opacity 140ms ease;
}

#hitFlash.on{
  opacity: 1;
  animation: hitPulseSoft 220ms ease-out;
}

@keyframes hitPulseSoft{
  0%   { opacity: 0; }
  35%  { opacity: 1; }
  100% { opacity: 0; }
}


/* small camera shake */
body.hitShake .app{
  animation: shake 260ms ease-out;
}
@keyframes shake{
  0%   { transform: translate3d(0,0,0); }
  15%  { transform: translate3d(-3px, 1px,0); }
  30%  { transform: translate3d( 3px,-2px,0); }
  45%  { transform: translate3d(-2px,-1px,0); }
  60%  { transform: translate3d( 2px, 2px,0); }
  100% { transform: translate3d(0,0,0); }
}

/* highlight the damaged party row */
.pRow.damaged{
  box-shadow: 0 0 0 2px rgba(255,80,80,0.55);
  background: rgba(255,60,60,0.10);
  transition: box-shadow 180ms ease, background 180ms ease;
}

/* ===== MOB DEATH FX ===== */
/* ===== MOB DEATH OVERLAY (image, not replacement) ===== */
.mobCard.dead{
  filter: grayscale(0.9) brightness(0.8);
}

.mobCard.dead .deathIcon{
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  pointer-events: none;
  z-index: 5;
}

.mobCard.dead .deathIcon img{
  width: 34px;
  height: 34px;
  opacity: 0.95;
  filter: drop-shadow(0 0 10px rgba(255,60,60,0.35));
  animation: deathBlink 650ms ease-in-out 3;
}

@keyframes deathBlink{
  0%,100% { opacity: 0.35; transform: scale(0.95); }
  50%     { opacity: 1.00; transform: scale(1.08); }
}

/* optional: a “loot toast” */
#lootToastHost{
  position: fixed;
  left: 50%;
  top: 14%;
  transform: translateX(-50%);
  z-index: 99996;
  pointer-events: none;
  display:flex;
  flex-direction:column;
  gap: 8px;
}

.lootToast{
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(6px);
  box-shadow: 0 16px 44px rgba(0,0,0,0.55);
  font-weight: 900;
  letter-spacing: 0.3px;
  opacity: 0;
  transform: translateY(-6px);
  animation: toastInOut 1600ms ease forwards;
}

@keyframes toastInOut{
  0%   { opacity:0; transform: translateY(-10px); }
  10%  { opacity:1; transform: translateY(0px); }
  80%  { opacity:1; transform: translateY(0px); }
  100% { opacity:0; transform: translateY(-10px); }
}


/* Logout button should be available when gameover appears*/
body.locked #gameOverOverlay button{
  pointer-events: auto;
}
</style>
</head>

<body>

<div id="rotateHint">
  <div>
    <div style="font-size:20px;margin-bottom:8px;">Bitte Gerät drehen</div>
    <div style="opacity:.75;font-size:14px;">Diese Ansicht ist für Querformat optimiert</div>
  </div>
</div>

<div class="app">

  <!-- TOPBAR -->
  <div class="topbar">
    <div class="title">
      <span>Marina Station: Last Stand</span>
      <span class="badge" id="playerBadge">Player: (loading…)</span>
      <span class="badge" id="turnBadge">Turn: 1</span>
    </div>
    <div class="topbarRight">
      <span class="badge" id="gameBadge">Game: 0</span>
      <button class="btnTop" id="btnLogout" title="Logout">Logout</button>
    </div>
  </div>

  <!-- MAIN -->
  <div class="main">

    <!-- ENCOUNTER -->
    <div class="panel encounterPanel">
      <div class="panelHeader">
        <span>Encounter</span>
        <div>
          <button class="btnTop" id="btnFlash" title="Flash">Flash: OFF</button>
          <button class="btnTop" id="btnShake" title="Shake">Shake: OFF</button>
        </div>
      </div>
      <div class="lanes" id="lanes"></div>
    </div>

    <!-- PARTY -->
    <div class="panel partyPanel">
      <div class="panelHeader">
        <span>Party</span>
        <span class="sub" id="partyCount">Players: 0</span>
        <button class="partyLogoutBtn" id="btnLogoutParty" type="button" title="Logout">
            Logout
        </button>
      </div>
      <div class="partyList" id="party"></div>
    </div>

  </div>

  <!-- BOTTOM HUD (10 buttons + inputs) -->
  <div class="hud">
    <div class="hudBar">
      <div class="actions" id="actions"></div>

      <input id="actionTarget"
             class="target-input"
             placeholder="Target" />

      <input id="actionMsg"
             class="chat-input"
             placeholder="Action / Message…" />
    </div>
  </div>

</div>

<div id="hitFlash"></div>
<div id="lootToastHost"></div>
<script>
  /* =========================
     Globals
     ========================= */
  let ENABLE_SHAKE = false;  // default on (you can set false)
  let ENABLE_HIT_FLASH = false; // default OFF (migraine-safe)


  /* =========================
     AUTH + STORAGE
     ========================= */
  const LOGIN_PAGE = "index.html"; // keep index.html as login page

  function getToken() {
    return localStorage.getItem("sessionToken") || "";
  }

  function getPlayerName() {
    return localStorage.getItem("playerName") || "";
  }

  function authHeaders(extra = {}) {
    const t = getToken();
    if (!t) return extra;
    return { ...extra, "Authorization": "Bearer " + t };
  }

  function requireAuthOrRedirect() {
    const t = getToken();
    if (!t) {
      window.location.href = LOGIN_PAGE;
    }
  }

  // Dead popup and loot
  // Keep dead mobs visible briefly (even if server removes them)
  const deadFx = new Map(); // id -> { untilMs, lastMob }
  const DEAD_STAY_MS = 2200;

  // load preference flash
  ENABLE_HIT_FLASH = (localStorage.getItem("enableHitFlash") ?? "0") === "1";


  // load preference SHAKE
  ENABLE_SHAKE = (localStorage.getItem("enableShake") ?? "1") === "1";

  function updateShakeBtn(){
    const b = document.getElementById("btnShake");
    if (!b) return;
    b.textContent = "Shake: " + (ENABLE_SHAKE ? "ON" : "OFF");
  }

  document.getElementById("btnShake")?.addEventListener("click", () => {
    ENABLE_SHAKE = !ENABLE_SHAKE;
    localStorage.setItem("enableShake", ENABLE_SHAKE ? "1" : "0");
    updateShakeBtn();
  });

  updateShakeBtn();
  // END Shake Option

  async function doLogout() {
    const token = getToken();
    try {
      document.getElementById("btnLogout")?.setAttribute("disabled", "disabled");
      document.getElementById("btnLogoutParty")?.setAttribute("disabled", "disabled");
    } catch (e) {}

    const clearLocal = () => {
      localStorage.removeItem("sessionToken");
      localStorage.removeItem("playerName");
      localStorage.removeItem("gameId");
    };

    if (!token) {
      clearLocal();
      window.location.href = LOGIN_PAGE;
      return;
    }
    try {
        const res = await fetch(LOGOUT_URL, {
          method: "POST",
          headers: authHeaders({ "Content-Type": "application/json" }),
          body: JSON.stringify({ gameId: String(getGameId()) })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          console.warn("Logout not OK:", res.status, txt);
        }
    } catch (e) {
      console.warn("Logout request failed (network):", e);
    } finally {
      clearLocal();
      window.location.href = LOGIN_PAGE;
    }
  }

  document.getElementById("btnLogout").addEventListener("click", doLogout);
  const btnLogoutParty = document.getElementById("btnLogoutParty");
  if (btnLogoutParty) btnLogoutParty.addEventListener("click", doLogout);

  requireAuthOrRedirect();

  const lastStateUpdateHash= "";

  /* =========================
     API ENDPOINTS
     ========================= */
  const ACTION_URL = "/api/v001/darawebgame/action";
  const STATE_URL  = "/api/v001/darawebgame/state";
  const LOGOUT_URL = "/api/v001/darawebgame/auth/logout";

  /* =========================
     MEDIA ICONS + HUD ACTIONS
     ========================= */
  const AVATAR_IMG_BASE = "https://gameinfo.daraempire.com/wp-content/uploads/";
  const IMG_BASE = "https://gameinfo.daraempire.com/wp-content/uploads/";
  const IMG_EXT = ".png";

  const MEDIA = {
    images: {
      attack: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/JumpAttack-150x150.png",
      defend: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellShieldDefense-150x150.png",
      fireball: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/Fireball-150x150.png",
      mezmerize: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellMezmerize-150x150.png",
      heal: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/PetComeToMe-150x150.png",
      revive: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellBuffConstitution-150x150.png",
      evac: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/ModeratorEvac-150x150.png",
      talk: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/RenameMe-150x150.png",
      usepotion: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/PotionManaExpert-150x150.png",
      shoot: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/Hitscan-150x150.png",
      dead: "https://gameinfo.daraempire.com/wp-content/uploads/Dead.png",
    }
  };
  const SOUND_BASE = "https://gameinfo.daraempire.com/wp-content/uploads/";

  const ACTION_SOUNDS = {
    attack:   new Audio(SOUND_BASE+"Attack.wav"),
    fireball: new Audio(SOUND_BASE+"Fireball.wav"),
    heal:     new Audio(SOUND_BASE+"Heal.wav"),
    defend:   new Audio(SOUND_BASE+"Defense.wav"),
    mezmerize:new Audio(SOUND_BASE+"Mez.wav"),
    revive:   new Audio(SOUND_BASE+"Revive.wav"),
    evac:     new Audio(SOUND_BASE+"Evac.wav"),
    talk:     new Audio(SOUND_BASE+"Talk.wav"),
    usepotion:new Audio(SOUND_BASE+"Potion.wav"),
    shoot:    new Audio(SOUND_BASE+"LaserGun1.wav"),
    mobdeath: new Audio(SOUND_BASE+"MobDeath.wav"),
    gameover: new Audio(SOUND_BASE+"GameOverSciFi.wav"),
    hit1: new Audio(SOUND_BASE+"PlayerHit1.wav"),
    hit2: new Audio(SOUND_BASE+"PlayerHit2.wav"),
    hit3: new Audio(SOUND_BASE+"PlayerHit3.wav"),
  };

  function playSound(key){
    const snd = ACTION_SOUNDS[key];
    if(!snd) return;
    try{
      snd.pause();
      snd.currentTime = 0;
      snd.play().catch(()=>{});
    }catch(e){}
  }

  let lastHitSoundAt = 0;

  function playRandomHitSound(){
    const now = performance.now();
    if (now - lastHitSoundAt < 180) return; // ms debounce
    lastHitSoundAt = now;

    const hits = ["hit1", "hit2", "hit3"];
    const key = hits[Math.floor(Math.random() * hits.length)];
    playSound(key);
  }

  const ACTIONS = [
    { id: "attack",     label: "Attack",   cd: 2  },
    { id: "defend",     label: "Defend",   cd: 3  },
    { id: "fireball",   label: "Fireball", cd: 5  },
    { id: "heal",       label: "Heal",     cd: 6  },
    { id: "mezmerize",  label: "Mez",      cd: 8  },
    { id: "shoot",      label: "Shoot",     cd: 1  },
    { id: "usepotion",  label: "Potion",   cd: 10 },
    { id: "talk",       label: "Talk",     cd: 1  },
    { id: "revive",     label: "Revive",   cd: 12 },
    { id: "evac",       label: "Evac",     cd: 20 },
  ];

  const actionsEl = document.getElementById("actions");
  const actionTargetEl = document.getElementById("actionTarget");
  const actionMsgEl = document.getElementById("actionMsg");

  function getActionTarget(){ return (actionTargetEl.value || "").trim(); }
  function getActionMsg(){ return (actionMsgEl.value || "").trim(); }

  /* Cooldown state */
  const cooldownUntil = new Map(); // actionId -> timestamp(ms)
  function nowMs(){ return Date.now(); }
  function startCooldown(actionId, seconds){
    cooldownUntil.set(actionId, nowMs() + seconds * 1000);
  }
  function getRemaining(actionId){
    const until = cooldownUntil.get(actionId) || 0;
    return Math.max(0, until - nowMs());
  }

  function setButtonCooldownUI(btn, remainingMs, totalMs){
    const timeEl = btn.querySelector(".cd-time");
    const fill = btn.querySelector(".cd-fill");

    if (remainingMs <= 0) {
      btn.classList.remove("cooldown");
      if (timeEl) timeEl.textContent = "";
      if (fill) fill.style.transform = "translateY(100%)";
      return;
    }

    btn.classList.add("cooldown");

    const sec = Math.ceil(remainingMs / 1000);
    if (timeEl) timeEl.textContent = String(sec);

    const pct = (remainingMs / totalMs) * 100;
    const y = 100 - pct;
    if (fill) fill.style.transform = `translateY(${y}%)`;
  }

  function buildButtons(){
    actionsEl.innerHTML = "";

    for(const a of ACTIONS){
      const btn = document.createElement("button");
      btn.className = "action-btn";
      btn.type = "button";
      btn.dataset.action = a.id;
      btn.dataset.cd = String(a.cd);

      const img = document.createElement("img");
      img.src = MEDIA.images[a.id] || "";
      img.alt = a.id;
      btn.appendChild(img);

      const fill = document.createElement("div");
      fill.className = "cd-fill";
      btn.appendChild(fill);

      const overlay = document.createElement("div");
      overlay.className = "cd-overlay";
      overlay.innerHTML = `<div class="cd-time"></div>`;
      btn.appendChild(overlay);

      const tip = document.createElement("div");
      tip.className = "tip";
      tip.textContent = a.label;
      btn.appendChild(tip);

      btn.addEventListener("click", async () => {
        const actionId = a.id;
        const cdSec = a.cd;

        if (getRemaining(actionId) > 0) return;
        playSound(actionId);

        const userName = getPlayerName();
        if (!userName) {
          console.warn("No playerName in localStorage yet");
          return;
        }

        startCooldown(actionId, cdSec);
        tickCooldowns();

        const actionTarget = getActionTarget();
        const actionMsg = getActionMsg() || actionId;

        try {
          const res = await fetch(ACTION_URL, {
            method: "POST",
            headers: authHeaders({ "Content-Type": "application/json" }),
            body: JSON.stringify({
              gameId: String(getGameId()),
              userName,
              actionId,
              actionTarget,
              actionMsg
            })
          });

          if (res.status === 401) doLogout();
        } catch (e) {
          console.error("Action POST failed:", e);
        }
      });

      actionsEl.appendChild(btn);
    }
  }

  function tickCooldowns(){
    document.querySelectorAll(".action-btn").forEach(btn => {
      const actionId = btn.dataset.action;
      const totalMs = Number(btn.dataset.cd) * 1000;
      const remainingMs = getRemaining(actionId);
      setButtonCooldownUI(btn, remainingMs, totalMs);
    });
  }

  actionMsgEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      const talkBtn = document.querySelector('.action-btn[data-action="talk"]');
      if (talkBtn) talkBtn.click();
    }
  });

  /* =========================
     GAME STATE (Encounter + Party)
     ========================= */

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function pct(v, max){ return max > 0 ? clamp01(v / max) : 0; }

  let uiState = {
    turn: 1,
    slots: 5,
    lanes: [
      { name: "LONG RANGE",  cls: "long",  range: "8–10m" },
      { name: "MID RANGE",   cls: "mid",   range: "4–7m"  },
      { name: "MELEE RANGE", cls: "melee", range: "0–3m"  },
    ],
    mobs: [
      { id: "MSAgent-Christie", lane:0, slot:1, hp:3, max:6 },
      { id: "Kinora", lane:1, slot:0, hp:3, max:6 },
      { id: "Insect", lane:1, slot:2, hp:14, max:14 },
      { id: "Spider", lane:2, slot:1, hp:15, max:30 },
      { id: "Kornrex", lane:2, slot:3, hp:25, max:40 },
    ],
    party: [
      { id:"Dara",   hp:7,  hpMax:15, en:40, enMax:40, mn:40, mnMax:40, active:true, avatarId: "MSAgent-Christie" },
      { id:"Korlan", hp:16, hpMax:20, en:45, enMax:45, mn:45, mnMax:45, active:false, avatarId: "MSAgent-Turnario" },
      { id:"Viper",  hp:11, hpMax:12, en:35, enMax:35, mn:55, mnMax:55, active:false, avatarId: "MSAgent-Soldorn" },
      { id:"Terik",  hp:8,  hpMax:10, en:55, enMax:55, mn:50, mnMax:50, active:false, avatarId: "MSAgent-Tira" },
    ],
    selectedMobId: null,
    selectedPartyId: null
  };

  function getGameId(){
    return localStorage.getItem("gameId") || "0";
  }

  function renderBadges(){
    document.getElementById("playerBadge").textContent = "Player: " + (getPlayerName() || "(not set)");
    document.getElementById("gameBadge").textContent = "Game: " + getGameId();
    document.getElementById("turnBadge").textContent = "Turn: " + (uiState.turn ?? 1);
    document.getElementById("partyCount").textContent = "Players: " + (uiState.party?.length ?? 0);
  }

  /* ===== Encounter: Depth Scene (UPDATED with selection marker) ===== */
  
  function renderEncounter(){
    const lanesEl = document.getElementById("lanes");
    lanesEl.innerHTML = "";

    const scene = document.createElement("div");
    scene.className = "scene";

    const fog1 = document.createElement("div");
    fog1.className = "fog";
    const fog2 = document.createElement("div");
    fog2.className = "fog f2";

    const layers = document.createElement("div");
    layers.className = "depthLayers";

    const rowBack  = document.createElement("div"); rowBack.className  = "depthRow back";
    const rowMid   = document.createElement("div"); rowMid.className   = "depthRow mid";
    const rowFront = document.createElement("div"); rowFront.className = "depthRow front";

    // Dead mobs should be shown a while with toast
    const now = Date.now();

    // alive mobs
    const alive = (uiState.mobs || []).filter(m => Number(m.hp) > 0);

    // cached corpses still visible
    const corpses = [];
    for (const [id, fx] of deadFx){
      if (fx.untilMs > now && fx.lastMob) corpses.push(fx.lastMob);
    }

    // combine alive + corpses
    const mobs = [...alive, ...corpses];

    const hpRatio = (m) => {
      const max = Number(m.max || m.hpMax || 1);
      const hp  = Number(m.hp || 0);
      return max > 0 ? Math.max(0, Math.min(1, hp / max)) : 0;
    };

    const isThreat = (m) => {
      const r = hpRatio(m);
      const inMelee = (m.lane === 2);
      const selected = (uiState.selectedMobId === m.id);
      return selected || inMelee || r >= 0.75;
    };

    function makeMobCard(m, idx){
      const wrap = document.createElement("div");
      wrap.className = "mobCardWrap";

      const x = ((m.slot ?? idx) - 2) * 18 + (idx % 2 ? 10 : -8);
      const y = (m.lane === 0 ? -10 : (m.lane === 1 ? -6 : -12));
      wrap.style.setProperty("--tx", `${x}px`);
      wrap.style.setProperty("--ty", `${y}px`);

      const card = document.createElement("div");
      const isDead = Number(m.hp) <= 0;

      card.className = "mobCard " + (isThreat(m) ? "threat" : "");
      if (isDead) card.classList.add("dead");
      card.classList.add(["t1","t2","t3","t4"][idx % 4]);

      if (uiState.selectedMobId === m.id){
        card.classList.add("selected");
      }

      const hpPct = hpRatio(m) * 100;
      const imgUrl = mobImageUrl(m.avatarId || m.id);

      card.innerHTML = `
        <div class="mob">
          <div class="targetTag">${escapeHtml(m.id)}</div>

          <img class="mobImg"
              src="${escapeHtml(imgUrl)}"
              alt="${escapeHtml(m.id)}"
              loading="lazy"
              onerror="this.style.display='none'; this.nextElementSibling.style.display='grid';" />
          <div class="avatar" style="display:none">${escapeHtml(m.id).slice(0,3)}</div>

          ${isDead ? `
            <div class="deathIcon">
              <img src="${MEDIA.images.dead}" alt="dead" />
            </div>
          ` : ""}

          <div class="hpBar">
            <div class="hpFill" style="width:${hpPct}%"></div>
          </div>
        </div>
      `;

      wrap.onclick = () => {
        if (isDead) return; // corpse not selectable
        uiState.selectedMobId = m.id;
        uiState.selectedPartyId = null;
        actionTargetEl.value = m.id;
        renderAll();
      };

      wrap.appendChild(card);
      return wrap;
    }

    const byThreatThenHP = (a,b) => {
      const ta = isThreat(a) ? 1 : 0;
      const tb = isThreat(b) ? 1 : 0;
      if (tb !== ta) return tb - ta;
      return hpRatio(b) - hpRatio(a);
    };

    const backMobs  = mobs.filter(m => m.lane === 0).sort(byThreatThenHP);
    const midMobs   = mobs.filter(m => m.lane === 1).sort(byThreatThenHP);
    const frontMobs = mobs.filter(m => m.lane === 2).sort(byThreatThenHP);

    backMobs.forEach((m,i)  => rowBack.appendChild(makeMobCard(m,i)));
    midMobs.forEach((m,i)   => rowMid.appendChild(makeMobCard(m,i)));
    frontMobs.forEach((m,i) => rowFront.appendChild(makeMobCard(m,i)));

    layers.appendChild(rowBack);
    layers.appendChild(rowMid);
    layers.appendChild(rowFront);

    scene.appendChild(layers);
    scene.appendChild(fog1);
    scene.appendChild(fog2);

    lanesEl.appendChild(scene);
  }
  
  function renderParty(){
    const partyEl = document.getElementById("party");
    partyEl.innerHTML = "";

    (uiState.party || []).forEach(p => {
      const row = document.createElement("div");
      row.className = "pRow";

      // add a transient "damaged" class if this player was hit recently
      if (uiState._damagedIds && uiState._damagedIds.has(p.id)){
        row.classList.add("damaged");
      }

      if (uiState.selectedPartyId === p.id) {
        row.classList.add("selected");
      }

      const hpP = pct(p.hp, p.hpMax);
      const enP = pct(p.en, p.enMax);
      const mnP = pct(p.mn, p.mnMax);

      const imgUrl = playerImageUrl(p.avatarId);

      row.innerHTML = `
        <div class="pAvatar">
          <img class="avatarImg"
               src="${escapeHtml(imgUrl)}"
               alt="${escapeHtml(p.id || "")}"
               loading="lazy"
               onerror="this.style.display='none'; this.nextElementSibling.style.display='grid';" />
          <div class="avatarText" style="display:none">
            ${escapeHtml((p.id||"?").slice(0,2).toUpperCase())}
          </div>
        </div>

        <div class="pInfo">
          <div class="pNameLine">
            <span class="name">${escapeHtml(p.id || "")}</span>
            <span class="meta">${p.active ? "ACTIVE" : ""}</span>
          </div>

          <div class="pBars">
            ${barRow("HP", hpP, `${p.hp}/${p.hpMax}`, "hp")}
            ${barRow("EN", enP, `${p.en}/${p.enMax}`, "en")}
            ${barRow("MN", mnP, `${p.mn}/${p.mnMax}`, "mn")}
          </div>
        </div>
      `;

      row.onclick = () => {
        const name = (p.id || "").trim();
        if (!name) return;

        actionTargetEl.value = name;

        uiState.selectedPartyId = p.id;
        uiState.selectedMobId = null;

        renderAll();
      };

      partyEl.appendChild(row);
    });
  }

  function barRow(label, percent01, rightText, cls){
    const w = Math.round(percent01 * 100);
    return `
      <div class="pBarRow">
        <div style="font-weight:900;opacity:.9;">${label}</div>
        <div class="pBar ${cls}"><div style="width:${w}%;"></div></div>
        <div style="text-align:right;opacity:.85;">${escapeHtml(rightText)}</div>
      </div>
    `;
  }

  let lastState = null;
  const playedDeaths = new Set();

  function extractMobsMap(state){
    const map = new Map();
    (state?.mobs || []).forEach(m => map.set(m.id, m));
    return map;
  }

  // Toast and Mobdeath detection
  function showLootToast(text){
  const host = document.getElementById("lootToastHost");
  if (!host) return;

  const el = document.createElement("div");
  el.className = "lootToast";
  el.textContent = text;

  host.appendChild(el);
  setTimeout(() => el.remove(), 1800);
}

function detectMobDeaths(prev, next){
  const prevMap = extractMobsMap(prev);
  const nextMap = extractMobsMap(next);

  const now = Date.now();

  // Case A: mob still exists but hp dropped to 0
  for(const [id, nextMob] of nextMap){
    const prevMob = prevMap.get(id);
    const wasAlive = prevMob ? (Number(prevMob.hp) > 0) : true;
    const isDead   = Number(nextMob.hp) <= 0;

    if (wasAlive && isDead && !playedDeaths.has(id)){
      playedDeaths.add(id);

      // sound
      playSound("mobdeath");

      // cache corpse
      deadFx.set(id, { untilMs: now + DEAD_STAY_MS, lastMob: { ...nextMob, hp: 0 } });

      // small reward feedback (placeholder)
      const gold = 1 + Math.floor(Math.random() * 4);
      showLootToast(`+${gold} Loot from ${id}`);
    }
  }

  // Case B: mob got removed from server list (disappears)
  for(const [id, prevMob] of prevMap){
    const existsNow = nextMap.has(id);
    const wasAlive = Number(prevMob.hp) > 0;

    if (wasAlive && !existsNow && !playedDeaths.has(id)){
      playedDeaths.add(id);

      playSound("mobdeath");
      deadFx.set(id, { untilMs: now + DEAD_STAY_MS, lastMob: { ...prevMob, hp: 0 } });

      const gold = 1 + Math.floor(Math.random() * 4);
      showLootToast(`+${gold} Loot from ${id}`);
    }
  }

  // cleanup old fx
  for (const [id, fx] of deadFx){
    if (now > fx.untilMs) deadFx.delete(id);
  }
}


  function renderAll(){
    renderBadges();
    renderEncounter();
    renderParty();
  }

  async function updateState(){
    try{
      const res = await fetch(STATE_URL, {
        headers: authHeaders(),
        cache: "no-store"
      });

      if (res.status === 401) {
        doLogout();
        return;
      }

      if(!res.ok){
        return;
      }

      const s = await res.json();

      // --- DAMAGE FEEDBACK (CURRENT PLAYER ONLY) ---
      const damages = detectPartyDamage(lastState || uiState, s);
      if (damages.length > 0){
        const me = getPlayerName(); // logged-in player name
        const myHit = damages.find(d => d.id === me);

        if (myHit){
          // scale flash intensity by damage amount
          const intensity = Math.min(0.45, 0.18 + myHit.dmg / 80);
          triggerHitFeedback(intensity);
          playRandomHitSound();

          // optional: briefly highlight your own party row
          s._damagedIds = new Set([me]);
          setTimeout(() => {
            if (uiState && uiState._damagedIds){
              uiState._damagedIds = null;
              renderParty();
            }
          }, 450);
        }
      }
      // end damage feedback



      detectMobDeaths(lastState || uiState, s);

      const keepSelectedMobId   = uiState.selectedMobId;
      const keepSelectedPartyId = uiState.selectedPartyId;

      uiState = s;

      // If server provides phase/gameover fields
      const wasGameOver = String(lastState?.phase || "") === "gameover";
      const isGameOver  = String(s.phase || "") === "gameover";
      
      if (String(s.phase || "") === "gameover") {
          showGameOverOverlay(s.gameOverReason, s.restartInMs);

          if (!wasGameOver) playSound("gameover");
      } else {
          hideGameOverOverlay();
      }


      if (s.selectedMobId == null)   uiState.selectedMobId   = keepSelectedMobId;
      if (s.selectedPartyId == null) uiState.selectedPartyId = keepSelectedPartyId;

      lastState = s;
      renderAll();
    } catch(e){
      // ignore network errors for now
    }
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  function mobImageUrl(mobId){
    if (!mobId) return "";
    const safe = mobId.replace(/[^a-zA-Z0-9_-]/g, "");
    return IMG_BASE + safe + IMG_EXT;
  }
  function playerImageUrl(avatarId){
    if (!avatarId) return "";
    const safe = avatarId.replace(/[^a-zA-Z0-9_-]/g, "");
    return AVATAR_IMG_BASE + safe + IMG_EXT;
  }

  /* =========================
   KEYBOARD SHORTCUTS (PC)
   ========================= */

  // Detect "desktop-ish" devices (fine pointer = mouse)
  const isDesktopInput = window.matchMedia("(pointer: fine)").matches;

  document.addEventListener("keydown", (e) => {
    if (!isDesktopInput) return;

    // Don't trigger while typing
    const tag = document.activeElement?.tagName;
    if (tag === "INPUT" || tag === "TEXTAREA") return;

    // Only digits 0–9
    if (!/^[0-9]$/.test(e.key)) return;

    // Map key -> action index
    const key = e.key;
    const index = key === "0" ? 9 : (Number(key) - 1);

    if (index < 0 || index >= ACTIONS.length) return;

    const actionId = ACTIONS[index].id;

    const btn = document.querySelector(
      `.action-btn[data-action="${actionId}"]`
    );

    if (!btn) return;

    // Prevent browser shortcuts (e.g. page search on some layouts)
    e.preventDefault();

    // Respect cooldowns (same behavior as clicking)
    if (btn.classList.contains("cooldown")) return;

    // Fire the action
    btn.click();
  });

  /* =========================
     BOOT
     ========================= */
  buildButtons();
  setInterval(tickCooldowns, 100);
  tickCooldowns();

  renderAll();

  setInterval(updateState, 2500);
  updateState();


  /* =========================
     Game Over
     ========================= */
function showGameOverOverlay(reason, restartInMs){
  const overlay = document.getElementById("gameOverOverlay");
  const reasonEl = document.getElementById("gameOverReason");
  const secEl = document.getElementById("gameOverSeconds");

  if (!overlay) return;

  reasonEl.textContent = reason || "You lost";
  const sec = Math.max(0, Math.ceil((Number(restartInMs) || 0) / 1000));
  secEl.textContent = String(sec);

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden", "false");
  document.body.classList.add("locked");
}

function hideGameOverOverlay(){
  const overlay = document.getElementById("gameOverOverlay");
  if (!overlay) return;

  overlay.classList.add("hidden");
  overlay.setAttribute("aria-hidden", "true");
  document.body.classList.remove("locked");
}

/* =========================
     HitFlash
     ========================= */
let lastHitFlashAt = 0;

function triggerHitFeedback(intensity01 = 0.7){
    if (!ENABLE_HIT_FLASH) return;

    const now = performance.now();
    if (now - lastHitFlashAt < 500) return; // prevent double blink
    lastHitFlashAt = now;

    const flash = document.getElementById("hitFlash");
    if (!flash) return;

    flash.classList.remove("on");
    void flash.offsetHeight; // restart animation
    flash.style.opacity = String(Math.max(0.2, Math.min(0.6, intensity01)));
    flash.classList.add("on");

    if (ENABLE_SHAKE){
      document.body.classList.add("hitShake");
      setTimeout(() => document.body.classList.remove("hitShake"), 260);
    }
 }

 function updateFlashBtn(){
  const b = document.getElementById("btnFlash");
  if (!b) return;
  b.textContent = "Flash: " + (ENABLE_HIT_FLASH ? "ON" : "OFF");
}

document.getElementById("btnFlash")?.addEventListener("click", () => {
  ENABLE_HIT_FLASH = !ENABLE_HIT_FLASH;
  localStorage.setItem("enableHitFlash", ENABLE_HIT_FLASH ? "1" : "0");
  updateFlashBtn();
});

updateFlashBtn();
 // end hitflash section

function extractPartyMap(state){
  const map = new Map();
  (state?.party || []).forEach(p => map.set(p.id, p));
  return map;
}

// returns array of {id, dmg, newHp, oldHp}
function detectPartyDamage(prev, next){
  const prevMap = extractPartyMap(prev);
  const out = [];

  for (const p of (next?.party || [])){
    const id = p.id;
    const prevP = prevMap.get(id);
    if (!prevP) continue;

    const oldHp = Number(prevP.hp ?? 0);
    const newHp = Number(p.hp ?? 0);

    if (newHp < oldHp){
      out.push({ id, dmg: oldHp - newHp, newHp, oldHp });
    }
  }
  return out;
}

// Bind overlay button AFTER the DOM exists
window.addEventListener("DOMContentLoaded", () => {
  document.getElementById("btnGameOverLogout")?.addEventListener("click", doLogout);
});

</script>


<!-- GAME OVER OVERLAY -->
<div id="gameOverOverlay" class="overlay hidden" aria-hidden="true">
  <div class="overlayCard">
    <div class="overlayTitle">YOU LOST</div>
    <div class="overlayReason" id="gameOverReason">All players are dead</div>

    <div class="overlayTimer">
      Restarting in <span id="gameOverSeconds">3</span>s…
    </div>
    <div style="margin-top:16px; display:flex; justify-content:center; gap:12px;">
      <button id="btnGameOverLogout" class="btnTop">
        Logout
      </button>
    </div>

    <div class="overlayHint">Get more help!!!</div>
  </div>
</div>
</body>
</html>
