<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="color-scheme" content="dark" />
<meta name="theme-color" content="#05070b" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<title>Dara – Game</title>

<style>
  :root{
    --gap: 10px;
    --panel-radius: 12px;
    --border: #2a3340;
    --bg: rgba(10,14,20,0.90);
    --bg2: rgba(0,0,0,0.28);
    --text: #e6e6e6;
    --muted: #9aa6b2;

    --slotSize: 58px;
    --topbarH: 50px;

    --partyMaxHMobile: 32vh;

    /* Encounter responsiveness */
    --sceneMinH: 420px;     /* desktop default */
    --mobCardSize: 96px;    /* desktop default */
    --mobImgSize: 64px;     /* desktop default */

    /* rolling text infoMsg */
    --infoSpeed: 80; /* pixels per second (default). Configurable. */
  }

  html, body { height: 100%; }
  html { background:#05070b; }
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 50% 20%, #121a2a 0%, #05070b 55%);
    color: var(--text);
    font-family: Arial, sans-serif;
    overflow: hidden;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }

  /* ---------- LAYOUT ---------- */
  .app{
    height: 100%;
    display: grid;
    grid-template-rows: var(--topbarH) 1fr auto;
    gap: var(--gap);
    padding: 10px;
    box-sizing: border-box;
  }

  .topbar{
    height: var(--topbarH);
    border: 1px solid var(--border);
    background: var(--bg);
    border-radius: var(--panel-radius);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 12px;
    box-sizing: border-box;
  }
  .title{
    display:flex;
    align-items:center;
    gap:10px;
    font-weight: 800;
    letter-spacing: 0.5px;
  }
  .badge{
    font-size: 12px;
    color: var(--muted);
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.04);
    padding: 4px 8px;
    border-radius: 999px;
    white-space: nowrap;
  }
  .topbarRight{
    display:flex;
    align-items:center;
    gap:10px;
  }

  .btnTop{
    height: 34px;
    padding: 0 12px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    cursor: pointer;
    font-weight: 800;
    letter-spacing: 0.3px;
  }
  .btnTop:hover { filter: brightness(1.15); }
  .btnTop:active { transform: translateY(1px); }

  .main{
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: var(--gap);
    min-height: 0;
  }

  .panel{
    border: 1px solid var(--border);
    background: var(--bg);
    border-radius: var(--panel-radius);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .panelHeader{
    padding: 8px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    display:flex;
    align-items:center;
    justify-content: space-between;
    font-weight: 800;
  }
  .panelHeader .sub{
    font-weight: 600;
    font-size: 12px;
    color: var(--muted);
  }

  /* ---------- ENCOUNTER host ---------- */
  .encounterPanel{ min-height: 0; }
  .encounterPanel .lanes{ padding: 10px; overflow:hidden; min-height:0; height:100%; }

  /* =========================
     BATTLEFIELD SCENE
     ========================= */
  .scene{
    position: relative;
    height: 100%;
    min-height: 0;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.08);
    overflow: hidden;

    background-image: url("https://gameinfo.daraempire.com/wp-content/uploads/2024/12/Battle-at-Delco-Towers-2.png");
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
  }

  /* tunnel light cone */
  .scene::before{
    content:"";
    position:absolute;
    inset:-22% -12%;
    background:
      conic-gradient(from 200deg at 50% 35%,
        rgba(140,210,255,0.0) 0deg,
        rgba(140,210,255,0.16) 18deg,
        rgba(140,210,255,0.0) 46deg,
        rgba(140,210,255,0.0) 360deg);
    filter: blur(6px);
    opacity: 0.95;
    pointer-events:none;
    animation: conePulse 5.5s ease-in-out infinite;
  }
  @keyframes conePulse{
    0%,100% { opacity:0.78; transform: translate3d(0,0,0) scale(1); }
    50%     { opacity:1.00; transform: translate3d(0,2px,0) scale(1.01); }
  }

  /* fog layers */
  .fog{
    position:absolute;
    left:-25%; right:-25%;
    height:40%;
    bottom:-10%;
    background:
      radial-gradient(60% 80% at 50% 60%, rgba(200,220,255,0.08) 0%, rgba(0,0,0,0) 65%),
      linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.38) 100%);
    filter: blur(12px);
    opacity:0.92;
    pointer-events:none;
    animation: fogDrift1 12s linear infinite;
    z-index: 3;
  }
  .fog.f2{
    height:52%;
    bottom:-22%;
    opacity:0.62;
    filter: blur(18px);
    animation: fogDrift2 18s linear infinite;
  }
  @keyframes fogDrift1{
    0%   { transform: translate3d(-40px, 0, 0) scale(1.02); }
    50%  { transform: translate3d( 40px,-6px,0) scale(1.04); }
    100% { transform: translate3d(-40px, 0, 0) scale(1.02); }
  }
  @keyframes fogDrift2{
    0%   { transform: translate3d( 60px, 0, 0) scale(1.08); }
    50%  { transform: translate3d(-60px,-10px,0) scale(1.10); }
    100% { transform: translate3d( 60px, 0, 0) scale(1.08); }
  }

  /* Absolute positioning layer for mobs */
  .battlefield{
    position:absolute;
    inset:0;
    pointer-events:none; /* wrappers re-enable */
    z-index: 2;
  }

  /* Mob wrapper positioned by x/y */
  .mobAbs{
    position:absolute;
    left: 0;
    top: 0;

    /* IMPORTANT: this makes movements smooth without recreating DOM */
    transition: left 120ms linear, top 120ms linear, transform 120ms linear;

    pointer-events:auto;
    transform-origin: 50% 90%;
  }

  /* Mob card (same look) */
  .mobCard{
    width: var(--mobCardSize);
    height: var(--mobCardSize);
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: linear-gradient(180deg, rgba(20,28,40,0.55) 0%, rgba(0,0,0,0.35) 100%);
    box-shadow: 0 14px 28px rgba(0,0,0,0.45);
    position:relative;
    overflow:hidden;
    cursor:pointer;

    --bobY: 6px;
    --bobT: 3.6s;
    animation: mobBob var(--bobT) ease-in-out infinite;
  }
  .mobCard.t1{ animation-delay: -0.3s; }
  .mobCard.t2{ animation-delay: -1.1s; }
  .mobCard.t3{ animation-delay: -2.0s; }
  .mobCard.t4{ animation-delay: -0.6s; }

  @keyframes mobBob{
    0%,100% { transform: translate3d(0,0,0) rotate(-0.15deg); }
    50%     { transform: translate3d(0,var(--bobY),0) rotate(0.20deg); }
  }

  /* threat glow */
  .mobCard.threat{
    border-color: rgba(120,200,255,0.28);
  }
  .mobCard.threat::after{
    content:"";
    position:absolute; inset:-2px;
    border-radius:14px;
    pointer-events:none;
    box-shadow: 0 0 0 1px rgba(120,200,255,0.35), 0 0 22px rgba(120,200,255,0.16);
    animation: threatPulse 2.2s ease-in-out infinite;
  }
  @keyframes threatPulse{
    0%,100% { opacity:0.55; filter: blur(0px); }
    50%     { opacity:1.00; filter: blur(0.2px); }
  }

  /* Selected marker */
  .mobCard.selected{
    border-color: rgba(120,200,255,0.70) !important;
    box-shadow:
      0 0 0 2px rgba(120,200,255,0.55),
      0 0 22px rgba(120,200,255,0.22),
      0 18px 30px rgba(0,0,0,0.45);
  }
  .mobCard.selected::before{
    content:"";
    position:absolute;
    inset: 6px;
    border-radius: 12px;
    background:
      linear-gradient(#7ad3ff,#7ad3ff) left top / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) left top / 2px 12px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right top / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right top / 2px 12px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) left bottom / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) left bottom / 2px 12px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right bottom / 12px 2px no-repeat,
      linear-gradient(#7ad3ff,#7ad3ff) right bottom / 2px 12px no-repeat;
    opacity: 0.95;
    pointer-events:none;
  }

  .mobCard .targetTag{
    position:absolute;
    top: 6px;
    left: 6px;
    font-size: 10px;
    font-weight: 900;
    letter-spacing: .4px;
    padding: 3px 6px;
    border-radius: 999px;
    background: rgba(120,200,255,0.16);
    border: 1px solid rgba(120,200,255,0.28);
    color: rgba(235,245,255,0.95);
    display:none;
    z-index: 3;
  }
  .mobCard.selected .targetTag{ display:block; }

  .mob{
    position:absolute;
    inset:0;
    display:grid;
    place-items:center;
  }

  .hpBar{
    position:absolute;
    left:10%;
    right:10%;
    bottom:4px;
    height:3px;
    background: rgba(255,255,255,0.14);
    border-radius: 6px;
    overflow:hidden;
  }
  .hpFill{
    height:100%;
    background: linear-gradient(90deg, #3cff9a, #ffd166, #ff4d4d);
  }

  .mobImg{
    width: var(--mobImgSize);
    height: var(--mobImgSize);
    border-radius: 10px;
    object-fit: cover;
    border: 1px solid rgba(255,255,255,0.22);
    box-shadow: 0 0 14px rgba(0,0,0,0.45);
  }

  .avatar{
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.22), rgba(0,0,0,0.35));
    display:grid;
    place-items:center;
    font-weight: 900;
    font-size: 12px;
  }

  /* death overlay */
  .mobCard.dead{
    filter: grayscale(0.9) brightness(0.8);
  }
  .mobCard.dead .deathIcon{
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: none;
    z-index: 5;
  }
  .mobCard.dead .deathIcon img{
    width: 34px;
    height: 34px;
    opacity: 0.95;
    filter: drop-shadow(0 0 10px rgba(255,60,60,0.35));
    animation: deathBlink 650ms ease-in-out 3;
  }
  @keyframes deathBlink{
    0%,100% { opacity: 0.35; transform: scale(0.95); }
    50%     { opacity: 1.00; transform: scale(1.08); }
  }

  /* reduced motion */
  @media (prefers-reduced-motion: reduce){
    .scene::before, .fog, .fog.f2, .mobCard, .mobAbs{ animation:none !important; transition:none !important; }
  }

  /* ---------- Info (non-moving, like your last state) ---------- */
  /* TEMP: hide info marquee */
  #infoMarquee{ display:none !important; }
  .infoMarquee{
    position: relative;
    height: 34px;
    flex: 1 1 auto;
    min-width: 140px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.22);
    overflow: hidden;
    display: flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
  }
  .infoMarquee::before,
  .infoMarquee::after{
    content:"";
    position:absolute;
    top:0; bottom:0;
    width: 18px;
    pointer-events:none;
    z-index: 2;
  }
  .infoMarquee::before{
    left:0;
    background: linear-gradient(90deg, rgba(0,0,0,0.45), rgba(0,0,0,0));
  }
  .infoMarquee::after{
    right:0;
    background: linear-gradient(270deg, rgba(0,0,0,0.45), rgba(0,0,0,0));
  }
  .infoTrack{ width:100%; overflow:hidden; white-space:nowrap; }
  .infoInner{ display:inline-flex; align-items:center; gap:28px; }
  .infoText{
    font-size: 12px;
    font-weight: 800;
    letter-spacing: 0.3px;
    color: rgba(255,255,255,0.86);
  }
  .infoMarquee.scrolling .infoInner{ animation: none !important; }

  /* ---------- PARTY ---------- */
  .pRow.selected{
    box-shadow: 0 0 0 2px rgba(120,200,255,0.55);
    background: rgba(30,60,120,0.18);
  }
  .partyList{
    padding: 8px;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }
  .pRow{
    display:grid;
    grid-template-columns: 32px 1fr;
    gap: 8px;
    padding: 8px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(0,0,0,0.18);
    margin-bottom: 8px;
  }
  .partyLogoutBtn{
    height: 26px;
    padding: 0 10px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    font-size: 12px;
    font-weight: 800;
    cursor: pointer;
  }
  .partyLogoutBtn:active{ transform: translateY(1px); }
  @media (min-width: 1025px){
    .partyLogoutBtn{ display: none; }
  }
  .pAvatar{
    width: 32px;
    height: 32px;
    border-radius: 10px;
    background: rgba(0,0,0,0.45);
    display:grid;
    place-items:center;
    font-weight: 900;
    font-size: 12px;
  }
  .avatarImg{
    width: 36px;
    height: 36px;
    border-radius: 10px;
    object-fit: cover;
    border: 1px solid rgba(255,255,255,0.22);
    box-shadow: 0 0 14px rgba(0,0,0,0.45);
  }
  .pInfo{
    display:flex;
    flex-direction:column;
    gap: 6px;
    min-width: 0;
  }
  .pNameLine{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 8px;
    font-size: 12px;
    font-weight: 800;
    min-width:0;
  }
  .pNameLine .name{
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .pNameLine .meta{
    font-size: 11px;
    color: var(--muted);
    white-space: nowrap;
    font-weight: 700;
  }
  .pBars{
    display:flex;
    flex-direction:column;
    gap: 6px;
  }
  .pBarRow{
    display:grid;
    grid-template-columns: 26px 1fr 38px;
    gap: 8px;
    align-items:center;
    font-size: 11px;
    color: rgba(255,255,255,0.82);
  }
  .pBar{
    height: 6px;
    background: rgba(255,255,255,0.14);
    border-radius: 6px;
    overflow:hidden;
  }
  .pBar > div { height:100%; width:50%; }
  .pBar.hp > div{ background: linear-gradient(90deg, #3cff9a, #ffd166, #ff4d4d); }
  .pBar.en > div{ background: linear-gradient(90deg, rgba(120,200,255,0.95), rgba(80,150,255,0.85)); }
  .pBar.mn > div{ background: linear-gradient(90deg, rgba(200,140,255,0.95), rgba(120,80,255,0.85)); }

  .pRow.damaged{
    box-shadow: 0 0 0 2px rgba(255,80,80,0.55);
    background: rgba(255,60,60,0.10);
    transition: box-shadow 180ms ease, background 180ms ease;
  }

  /* --- Level badge in party list --- */
.lvlBadge{
  font-size: 11px;
  font-weight: 900;
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.90);
  white-space: nowrap;
}

/* --- XP bar style (purple-ish) --- */
.pBar.xp > div{
  background: linear-gradient(90deg, rgba(200,140,255,0.95), rgba(255,210,120,0.90));
}

  /* ---------- BOTTOM HUD ---------- */
  .hud{
    border: 1px solid var(--border);
    background: var(--bg);
    border-radius: var(--panel-radius);
    padding: 8px;
    box-sizing: border-box;
  }
  .hudBar{
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .target-input{
    width: 120px;
    height: 34px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    padding: 0 10px;
    font-size: 13px;
    flex: 0 0 auto;
  }
  .chat-input{
    flex: 1;
    height: 34px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.28);
    color: #fff;
    padding: 0 14px;
    font-size: 14px;
  }
  .chat-input::placeholder{ opacity: 0.65; }
  .chat-input:focus{
    border-color: rgba(120,170,255,0.55);
    box-shadow: 0 0 0 3px rgba(120,170,255,0.15);
  }

  .actions{
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: 44px;
    gap: 8px;
    justify-content: start;
    flex: 0 0 auto;
  }
  .action-btn{
    width: 44px;
    height: 44px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,0.25);
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    user-select: none;
    cursor: pointer;
  }
  .action-btn img{
    width: 28px;
    height: 28px;
    object-fit: contain;
    pointer-events: none;
  }
  .action-btn .tip{
    position: absolute;
    bottom: 1px;
    left: 3px;
    right: 3px;
    font-size: 9px;
    opacity: 0.8;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    pointer-events: none;
  }
  .action-btn:hover{ filter: brightness(1.15); }
  .action-btn:active{ transform: translateY(1px); }

  .action-btn.disabled{
    opacity: 0.45;
    filter: grayscale(0.85);
    pointer-events: none;
  }

  /* ===== ACTION BUTTON COUNTER ===== */
  .action-btn .count{
    position: absolute;
    inset: 0;
    display: none;                 /* hidden by default */
    align-items: center;
    justify-content: center;
    font-weight: 900;
    font-size: 16px;
    color: #fff;
    text-shadow:
      0 0 6px rgba(0,0,0,0.9),
      0 0 12px rgba(0,0,0,0.6);
    pointer-events: none;
    z-index: 3;
  }

  /* slightly smaller on mobile */
  @media (max-width: 900px){
    .action-btn .count{ font-size: 14px; }
  }


  /* Cooldown overlay */
  .cd-overlay{
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.55);
    z-index: 2;
  }
  .cd-time{
    font-weight: 900;
    font-size: 14px;
    text-shadow: 0 0 6px rgba(0,0,0,0.9);
  }
  .action-btn.cooldown{
    filter: grayscale(0.6);
    opacity: 0.9;
  }
  .action-btn.cooldown .cd-overlay{ display:flex; }
  .cd-fill{
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.45);
    transform: translateY(100%);
    z-index: 1;
    pointer-events: none;
  }

  /* ---------- MOBILE ---------- */
  @media (max-width: 900px){
    :root{
      --gap: 8px;
      --sceneMinH: 240px;
      --mobCardSize: 58px;
      --mobImgSize: 36px;
    }
    .app{ padding: 8px; }
    .main{
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
    .partyPanel{
      max-height: var(--partyMaxHMobile);
      min-height: 0;
    }
    .hudBar{ flex-wrap: wrap; }
    .chat-input{ min-width: 160px; }
  }

  @media (min-width: 901px){
    :root{
      --sceneMinH: 520px;
      --mobCardSize: 128px;
      --mobImgSize: 96px;
    }
  }

  @media (max-width: 420px){
    .actions{ grid-template-columns: repeat(5, 40px); }
    .action-btn{ width: 40px; height: 40px; }
    .action-btn img{ width: 24px; height: 24px; }
  }

  /* Rotate hint */
  #rotateHint{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    z-index: 99999;
    display: none;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: #fff;
    font-weight: 800;
    letter-spacing: 0.5px;
  }
  @media (orientation: portrait){
    #rotateHint{ display: flex; }
  }

  /* ===== Landscape mobile block ===== */
  @media (orientation: landscape) and (max-width: 1024px){
    :root{
      --gap: 6px;
      --sceneMinH: 220px;
      --mobCardSize: 58px;
      --mobImgSize: 32px;
    }
    .topbar{ display: none; }
    .app{ grid-template-rows: 1fr auto; }
    .main{
      grid-template-columns: 400px 200px;
      grid-template-rows: 1fr;
      gap: 6px;
    }
    .partyPanel{ max-height: none; }
    .panelHeader{ padding: 6px 10px; font-size: 13px; }
    .panelHeader .sub{ font-size: 11px; }
    .lanes{ padding: 6px; }
    .hudBar{ flex-wrap: nowrap; }
    .chat-input{ min-width: 0; height: 32px; font-size: 13px; }
    .target-input{ width: 95px; height: 32px; font-size: 12px; }
    .actions{ grid-auto-columns: 40px; gap: 6px; }
    .action-btn{ width: 40px; height: 40px; }
    .action-btn img{ width: 24px; height: 24px; }
  }

  /* ===== GAME OVER OVERLAY ===== */
  .overlay{
    position: fixed;
    inset: 0;
    z-index: 99998;
    display: grid;
    place-items: center;
    background: rgba(0,0,0,0.72);
    backdrop-filter: blur(6px);
  }
  .overlay.hidden{ display:none; }
  .overlayCard{
    width: min(520px, 92vw);
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.16);
    background: linear-gradient(180deg, rgba(25,10,12,0.86) 0%, rgba(0,0,0,0.55) 100%);
    box-shadow: 0 24px 60px rgba(0,0,0,0.65);
    padding: 18px 18px 16px;
    text-align: center;
  }
  .overlayTitle{
    font-weight: 900;
    letter-spacing: 1px;
    font-size: 34px;
    text-transform: uppercase;
    text-shadow: 0 0 22px rgba(255,70,70,0.25);
  }
  .overlayReason{
    margin-top: 6px;
    color: rgba(255,255,255,0.85);
    font-size: 14px;
  }
  .overlayTimer{
    margin-top: 14px;
    font-weight: 900;
    font-size: 16px;
    color: rgba(255,255,255,0.92);
  }
  .overlayHint{
    margin-top: 10px;
    font-size: 12px;
    color: rgba(255,255,255,0.62);
  }
  #btnGameOverLogout{
    background: linear-gradient(180deg, rgba(120,20,20,0.9), rgba(60,10,10,0.9));
    border-color: rgba(255,80,80,0.5);
  }
  #btnGameOverLogout:hover{ filter: brightness(1.15); }
  body.locked .action-btn,
  body.locked .chat-input,
  body.locked .target-input{
    pointer-events: none;
    filter: grayscale(0.4);
    opacity: 0.85;
  }
  body.locked #gameOverOverlay button{ pointer-events: auto; }
  /* ===== WAVE COMPLETED OVERLAY ===== */
  #waveOverlay{
    position: fixed;
    inset: 0;
    z-index: 99995;          /* below gameOver (99998) but above everything else */
    display: grid;
    place-items: center;
    background: rgba(0,0,0,0.35);
    backdrop-filter: blur(2px);
    pointer-events: none;    /* allow UI to still be used if you want */
  }

  #waveOverlay.hidden{ display:none; }

  .waveCard{
    width: min(560px, 92vw);
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(0,0,0,0.55);
    box-shadow: 0 24px 60px rgba(0,0,0,0.55);
    padding: 14px 16px;
    text-align: center;
  }

  .waveTitle{
    font-weight: 900;
    letter-spacing: 0.8px;
    font-size: 20px;
  }

  .waveSub{
    margin-top: 6px;
    font-size: 12px;
    color: rgba(255,255,255,0.78);
  }




  /* ===== DAMAGE FEEDBACK ===== */
  #hitFlash{
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 99997;
    opacity: 0;
    background:
      radial-gradient(70% 55% at 50% 40%, rgba(180,60,60,0.12), rgba(0,0,0,0) 65%),
      linear-gradient(180deg, rgba(120,30,30,0.06), rgba(0,0,0,0));
    transition: opacity 140ms ease;
  }
  #hitFlash.on{
    opacity: 1;
    animation: hitPulseSoft 220ms ease-out;
  }
  @keyframes hitPulseSoft{
    0%   { opacity: 0; }
    35%  { opacity: 1; }
    100% { opacity: 0; }
  }
  body.hitShake .app{ animation: shake 260ms ease-out; }
  @keyframes shake{
    0%   { transform: translate3d(0,0,0); }
    15%  { transform: translate3d(-3px, 1px,0); }
    30%  { transform: translate3d( 3px,-2px,0); }
    45%  { transform: translate3d(-2px,-1px,0); }
    60%  { transform: translate3d( 2px, 2px,0); }
    100% { transform: translate3d(0,0,0); }
  }

  /* loot toast */
  #lootToastHost{
    position: fixed;
    left: 50%;
    top: 14%;
    transform: translateX(-50%);
    z-index: 99996;
    pointer-events: none;
    display:flex;
    flex-direction:column;
    gap: 8px;
  }
  .lootToast{
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(6px);
    box-shadow: 0 16px 44px rgba(0,0,0,0.55);
    font-weight: 900;
    letter-spacing: 0.3px;
    opacity: 0;
    transform: translateY(-6px);
    animation: toastInOut 1800ms ease forwards;
  }
  @keyframes toastInOut{
    0%   { opacity:0; transform: translateY(-10px); }
    10%  { opacity:1; transform: translateY(0px); }
    80%  { opacity:1; transform: translateY(0px); }
    100% { opacity:0; transform: translateY(-10px); }
  }

  /* ===== TOAST VARIANTS ===== */
  .lootToast.toastError{
    border-color: rgba(255,80,80,0.45);
    background: rgba(80,10,10,0.70);
    box-shadow: 0 18px 48px rgba(0,0,0,0.55), 0 0 24px rgba(255,80,80,0.10);
  }

  .lootToast.toastWarn{
    border-color: rgba(255,190,80,0.45);
    background: rgba(80,50,10,0.65);
  }

  .lootToast.toastInfo{
    border-color: rgba(120,200,255,0.35);
    background: rgba(10,25,45,0.60);
  }
  .lootToast.toastSuccess{
  border-color: rgba(80,255,140,0.40);
  background: rgba(10,70,30,0.65);
  box-shadow: 0 18px 48px rgba(0,0,0,0.55), 0 0 24px rgba(80,255,140,0.10);
  }
</style>
</head>

<body>

<div id="rotateHint">
  <div>
    <div style="font-size:20px;margin-bottom:8px;">Bitte Gerät drehen</div>
    <div style="opacity:.75;font-size:14px;">Diese Ansicht ist für Querformat optimiert</div>
  </div>
</div>

<div class="app">

  <!-- TOPBAR -->
  <div class="topbar">
    <div class="title">
      <span>Marina Station: Last Stand</span>
      <span class="badge" id="playerBadge">Player: (loading…)</span>
      <span class="badge" id="waveBadge">Wave: 1</span>
      <span class="badge" id="turnBadge">Turn: 1</span>
    </div>
    <div class="topbarRight">
      <span class="badge" id="gameBadge">Game: 0</span>
      <button id="btnHelp" class="top-btn" type="button">Help</button>
      <button class="btnTop" id="btnLogout" title="Logout">Logout</button>
    </div>
  </div>

  <!-- MAIN -->
  <div class="main">

    <!-- ENCOUNTER -->
    <div class="panel encounterPanel">
      <div class="panelHeader">
        <span>Encounter</span>
        <div style="display:flex; align-items:center; gap:10px; flex:1; min-width:0;">
          <input id="actionTarget" class="target-input" placeholder="Target" />

          <!-- Rolling info message (currently static) -->
          <div id="infoMarquee" class="infoMarquee" title="">
            <div class="infoTrack">
              <div class="infoInner" id="infoInner">
                <span class="infoText" id="infoTextA"></span>
              </div>
            </div>
          </div>
        </div>
        <div>
          <button class="btnTop" id="btnFlash" title="Flash">Flash: OFF</button>
          <button class="btnTop" id="btnShake" title="Shake">Shake: OFF</button>
        </div>
      </div>

      <!-- Container stays the same, but we render the battlefield scene into it -->
      <div class="lanes" id="lanes"></div>
    </div>

    <!-- PARTY -->
    <div class="panel partyPanel">
      <div class="panelHeader">
        <span>Party</span>
        <span class="sub" id="partyCount">Players: 0</span>
        <button class="partyLogoutBtn" id="btnLogoutParty" type="button" title="Logout">Logout</button>
      </div>
      <div class="partyList" id="party"></div>
    </div>

  </div>

  <!-- BOTTOM HUD -->
  <div class="hud">
    <div class="hudBar">
      <div class="actions" id="actions"></div>
      <input id="actionMsg" class="chat-input" placeholder="Action / Message…" />
    </div>
  </div>

</div>

<div id="hitFlash"></div>
<div id="lootToastHost"></div>

<script>
/* ======================================================================
   GLOBALS (BEGIN)
   ====================================================================== */
let ENABLE_SHAKE = false;
let ENABLE_HIT_FLASH = false;
let INFO_SPEED_PX_PER_SEC = Number(localStorage.getItem("infoSpeedPxPerSec") || "80");

/* Keep dead mobs visible briefly (even if server removes them) */
const deadFx = new Map(); // id -> { untilMs, lastMob }
const DEAD_STAY_MS = 2200;

/* IMPORTANT: DOM cache => prevents flicker (no re-create each tick) */
const mobDom = new Map(); // id -> { wrap, card, img, hpFill, targetTag, avatarFallback }

/* ======================================================================
   GLOBALS (END)
   ====================================================================== */


/* ======================================================================
   AUTH + STORAGE (BEGIN)
   ====================================================================== */
const LOGIN_PAGE = "index.html";

function getToken() { return localStorage.getItem("sessionToken") || ""; }           // (END getToken)
function getPlayerName() { return localStorage.getItem("playerName") || ""; }       // (END getPlayerName)
function getGameId(){ return localStorage.getItem("gameId") || "0"; }               // (END getGameId)

function authHeaders(extra = {}) {
  const t = getToken();
  if (!t) return extra;
  return { ...extra, "Authorization": "Bearer " + t };
} // (END authHeaders)

function requireAuthOrRedirect() {
  const t = getToken();
  if (!t) window.location.href = LOGIN_PAGE;
} // (END requireAuthOrRedirect)

/* Load preferences */
ENABLE_HIT_FLASH = (localStorage.getItem("enableHitFlash") ?? "0") === "1";
ENABLE_SHAKE = (localStorage.getItem("enableShake") ?? "1") === "1";

function updateShakeBtn(){
  const b = document.getElementById("btnShake");
  if (!b) return;
  b.textContent = "Shake: " + (ENABLE_SHAKE ? "ON" : "OFF");
} // (END updateShakeBtn)

document.getElementById("btnShake")?.addEventListener("click", () => {
  ENABLE_SHAKE = !ENABLE_SHAKE;
  localStorage.setItem("enableShake", ENABLE_SHAKE ? "1" : "0");
  updateShakeBtn();
});
updateShakeBtn();

async function doLogout() {
  const token = getToken();
  try {
    document.getElementById("btnLogout")?.setAttribute("disabled", "disabled");
    document.getElementById("btnLogoutParty")?.setAttribute("disabled", "disabled");
  } catch (e) {}

  const clearLocal = () => {
    localStorage.removeItem("sessionToken");
    localStorage.removeItem("playerName");
    localStorage.removeItem("gameId");
  };

  if (!token) {
    clearLocal();
    window.location.href = LOGIN_PAGE;
    return;
  }
  resetPlayerStatTracking();
  try {
    const res = await fetch(LOGOUT_URL, {
      method: "POST",
      headers: authHeaders({ "Content-Type": "application/json" }),
      body: JSON.stringify({ gameId: String(getGameId()) })
    });

    if (!res.ok) {
      const txt = await res.text().catch(() => "");
      console.warn("Logout not OK:", res.status, txt);
    }
  } catch (e) {
    console.warn("Logout request failed (network):", e);
  } finally {
    clearLocal();
    window.location.href = LOGIN_PAGE;
  }
} // (END doLogout)

document.getElementById("btnLogout").addEventListener("click", doLogout);
document.getElementById("btnLogoutParty")?.addEventListener("click", doLogout);

requireAuthOrRedirect();
/* ======================================================================
   AUTH + STORAGE (END)
   ====================================================================== */


/* ======================================================================
   API ENDPOINTS (BEGIN)
   ====================================================================== */
const ACTION_URL = "/api/v001/darawebgame/action";
const STATE_URL  = "/api/v001/darawebgame/state";
const LOGOUT_URL = "/api/v001/darawebgame/auth/logout";
/* ======================================================================
   API ENDPOINTS (END)
   ====================================================================== */


/* ======================================================================
   MEDIA + ACTIONS (BEGIN)
   ====================================================================== */
const AVATAR_IMG_BASE = "https://gameinfo.daraempire.com/wp-content/uploads/";
const IMG_BASE = "https://gameinfo.daraempire.com/wp-content/uploads/";
const IMG_EXT = ".png";
const ACTION_COSTS = {
  attack:     { res: "en", cost: 10 },
  defend:     { res: "en", cost: 10 },
  fireball:   { res: "mn", cost: 10 },
  heal:       { res: "mn", cost: 10 },
  mezmerize:  { res: "mn", cost: 10 },
  shoot:      { res: "en", cost: 10 },
  usepotion:  { res: null, cost: 0  },
  talk:       { res: null, cost: 0  },
  revive:     { res: "mn", cost: 10 },   // or "en" if you want
  evac:       { res: null, cost: 0  }
};
const MEDIA = {
  images: {
    attack: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/JumpAttack-150x150.png",
    defend: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellShieldDefense-150x150.png",
    fireball: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/Fireball-150x150.png",
    mezmerize: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellMezmerize-150x150.png",
    heal: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/PetComeToMe-150x150.png",
    revive: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/SpellBuffConstitution-150x150.png",
    evac: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/ModeratorEvac-150x150.png",
    talk: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/RenameMe-150x150.png",
    usepotion: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/PotionManaExpert-150x150.png",
    shoot: "https://gameinfo.daraempire.com/wp-content/uploads/2026/01/Hitscan-150x150.png",
    dead: "https://gameinfo.daraempire.com/wp-content/uploads/Dead.png",
  }
};

const SOUND_BASE = "https://gameinfo.daraempire.com/wp-content/uploads/";
const ACTION_SOUNDS = {
  attack:   new Audio(SOUND_BASE+"Attack.wav"),
  fireball: new Audio(SOUND_BASE+"Fireball.wav"),
  heal:     new Audio(SOUND_BASE+"Heal.wav"),
  defend:   new Audio(SOUND_BASE+"Defense.wav"),
  mezmerize:new Audio(SOUND_BASE+"Mez.wav"),
  revive:   new Audio(SOUND_BASE+"Revive.wav"),
  evac:     new Audio(SOUND_BASE+"Evac.wav"),
  talk:     new Audio(SOUND_BASE+"Talk.wav"),
  usepotion:new Audio(SOUND_BASE+"Potion.wav"),
  shoot:    new Audio(SOUND_BASE+"LaserGun1.wav"),
  mobdeath: new Audio(SOUND_BASE+"MobDeath.wav"),
  gameover: new Audio(SOUND_BASE+"GameOverSciFi.wav"),
  hit1: new Audio(SOUND_BASE+"PlayerHit1.wav"),
  hit2: new Audio(SOUND_BASE+"PlayerHit2.wav"),
  hit3: new Audio(SOUND_BASE+"PlayerHit3.wav"),
};

function playSound(key){
  const snd = ACTION_SOUNDS[key];
  if(!snd) return;
  try{
    snd.pause();
    snd.currentTime = 0;
    snd.play().catch(()=>{});
  }catch(e){}
} // (END playSound)

let lastHitSoundAt = 0;
function playRandomHitSound(){
  const now = performance.now();
  if (now - lastHitSoundAt < 180) return;
  lastHitSoundAt = now;
  const hits = ["hit1", "hit2", "hit3"];
  playSound(hits[Math.floor(Math.random() * hits.length)]);
} // (END playRandomHitSound)

const ACTIONS = [
  { id: "shoot",      label: "Shoot",    cd: 1  },
  { id: "fireball",   label: "Fireball", cd: 5  },
  { id: "attack",     label: "Attack",   cd: 2  },
  { id: "defend",     label: "Defend",   cd: 3  },
  { id: "heal",       label: "Heal",     cd: 6  },
  { id: "mezmerize",  label: "Mez",      cd: 8  },
  { id: "usepotion",  label: "Potion",   cd: 10 },
  { id: "talk",       label: "Talk",     cd: 1  },
  { id: "revive",     label: "Revive",   cd: 12 },
  { id: "evac",       label: "Evac",     cd: 20 },
];

const actionsEl = document.getElementById("actions");
const actionTargetEl = document.getElementById("actionTarget");
const actionMsgEl = document.getElementById("actionMsg");

function getActionTarget(){ return (actionTargetEl.value || "").trim(); } // (END getActionTarget)
function getActionMsg(){ return (actionMsgEl.value || "").trim(); }       // (END getActionMsg)

/* Cooldown state */
const cooldownUntil = new Map();
function nowMs(){ return Date.now(); } // (END nowMs)

function startCooldown(actionId, seconds){
  cooldownUntil.set(actionId, nowMs() + seconds * 1000);
} // (END startCooldown)

function getRemaining(actionId){
  const until = cooldownUntil.get(actionId) || 0;
  return Math.max(0, until - nowMs());
} // (END getRemaining)

function setButtonCooldownUI(btn, remainingMs, totalMs){
  const timeEl = btn.querySelector(".cd-time");
  const fill = btn.querySelector(".cd-fill");

  if (remainingMs <= 0) {
    btn.classList.remove("cooldown");
    if (timeEl) timeEl.textContent = "";
    if (fill) fill.style.transform = "translateY(100%)";
    return;
  }

  btn.classList.add("cooldown");
  const sec = Math.ceil(remainingMs / 1000);
  if (timeEl) timeEl.textContent = String(sec);

  const pct = (remainingMs / totalMs) * 100;
  const y = 100 - pct;
  if (fill) fill.style.transform = `translateY(${y}%)`;
} // (END setButtonCooldownUI)

function buildButtons(){
  actionsEl.innerHTML = "";

  for(const a of ACTIONS){
    const btn = document.createElement("button");
    btn.className = "action-btn";
    btn.type = "button";
    btn.dataset.action = a.id;
    btn.dataset.cd = String(a.cd);

    // --- icon ---
    const img = document.createElement("img");
    img.src = MEDIA.images[a.id] || "";
    img.alt = a.id;
    btn.appendChild(img);

    // --- centered counter (potions, ammo, charges, etc.) ---
    const count = document.createElement("div");
    count.className = "count";
    btn.appendChild(count);

    // --- cooldown fill ---
    const fill = document.createElement("div");
    fill.className = "cd-fill";
    btn.appendChild(fill);

    // --- cooldown overlay (number) ---
    const overlay = document.createElement("div");
    overlay.className = "cd-overlay";
    overlay.innerHTML = `<div class="cd-time"></div>`;
    btn.appendChild(overlay);

    // --- label ---
    const tip = document.createElement("div");
    tip.className = "tip";
    tip.textContent = a.label;
    btn.appendChild(tip);

    btn.addEventListener("click", async () => {
      const actionId = a.id;
      const cdSec = a.cd;

      // cooldown check
      if (getRemaining(actionId) > 0) return;

      // block potion use if none
      if (actionId === "usepotion"){
        const n = getPotionCount ? getPotionCount() : 0;
        if (Number(n) <= 0){
          if (typeof showToast === "function") showToast("No potions left", "error", 1500);
          return;
        }
      }

      // resource check (energy/mana) if you use ACTION_COSTS with {res,cost}
      if (typeof canPayCost === "function"){
        const pay = canPayCost(actionId);
        if (pay && pay.ok === false){
          const label = (typeof resLabel === "function") ? resLabel(pay.res) : (pay.res || "Resource");
          if (typeof showToast === "function"){
            showToast(`Not enough ${label} for ${actionId.toUpperCase()} (${pay.cur}/${pay.need})`, "error", 1700);
          }
          return;
        }
      }

      // play sound
      playSound(actionId);

      const userName = getPlayerName();
      if (!userName) {
        console.warn("No playerName in localStorage yet");
        return;
      }

      // start cooldown
      startCooldown(actionId, cdSec);
      tickCooldowns();

      const actionTargetInput = getActionTarget();
      const actionTarget = resolveTargetIdFromInput(actionTargetInput);
      const actionMsg = getActionMsg() || actionId;

      try {
        const res = await fetch(ACTION_URL, {
          method: "POST",
          headers: authHeaders({ "Content-Type": "application/json" }),
          body: JSON.stringify({
            gameId: String(getGameId()),
            userName,
            actionId,
            actionTarget,
            actionMsg
          })
        });

        if (res.status === 401) doLogout();

        // optional: if server returns error json/text, show as toast
        if (!res.ok && typeof showToast === "function"){
          const txt = await res.text().catch(() => "");
          const msg = txt ? txt.slice(0, 140) : `Action failed (${res.status})`;
          showToast(msg, "error", 1800);
        }
      } catch (e) {
        console.error("Action POST failed:", e);
        if (typeof showToast === "function") showToast("Network error: action not sent", "error", 1800);
      }
    });

    actionsEl.appendChild(btn);
  }
} // (END buildButtons)


  function tickCooldowns(){
    document.querySelectorAll(".action-btn").forEach(btn => {
      const actionId = btn.dataset.action;

      // existing cooldown logic
      const totalMs = Number(btn.dataset.cd) * 1000;
      const remainingMs = getRemaining(actionId);
      setButtonCooldownUI(btn, remainingMs, totalMs);

      // ===== COUNTERS =====
      const countEl = btn.querySelector(".count");
      if (!countEl) return;

      if (actionId === "usepotion"){
        const n = getPotionCount();

        if (n > 0){
          countEl.textContent = String(n);
          countEl.style.display = "flex";
        } else {
          countEl.style.display = "none";
        }
      } else {
        countEl.style.display = "none";
      }
    });
  } // (END tickCooldowns)

actionMsgEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    const talkBtn = document.querySelector('.action-btn[data-action="talk"]');
    if (talkBtn) talkBtn.click();
  }
});
/* ======================================================================
   MEDIA + ACTIONS (END)
   ====================================================================== */


/* ======================================================================
   UI STATE + BASIC HELPERS (BEGIN)
   ====================================================================== */
function clamp01(x){ return Math.max(0, Math.min(1, x)); } // (END clamp01)
function pct(v, max){ return max > 0 ? clamp01(v / max) : 0; } // (END pct)

/* Demo state (server will override via /state) */
let uiState = {
  turn: 1,
  mobs: [
    { id: "MSAgent-Christie", x:0.18, y:0.72, hp:3,  max:6  },
    { id: "Kinora",           x:0.35, y:0.52, hp:3,  max:6  },
    { id: "Insect",           x:0.58, y:0.48, hp:14, max:14 },
    { id: "Spider",           x:0.72, y:0.78, hp:15, max:30 },
    { id: "Kornrex",          x:0.86, y:0.82, hp:25, max:40 },
  ],
  party: [
    { id:"Dara",   hp:7,  hpMax:15, en:40, enMax:40, mn:40, mnMax:40, active:true,  avatarId: "MSAgent-Christie" },
    { id:"Korlan", hp:16, hpMax:20, en:45, enMax:45, mn:45, mnMax:45, active:false, avatarId: "MSAgent-Turnario" },
    { id:"Viper",  hp:11, hpMax:12, en:35, enMax:35, mn:55, mnMax:55, active:false, avatarId: "MSAgent-Soldorn" },
    { id:"Terik",  hp:8,  hpMax:10, en:55, enMax:55, mn:50, mnMax:50, active:false, avatarId: "MSAgent-Tira" },
  ],
  selectedMobId: null,
  selectedPartyId: null
};

function renderBadges(){
  document.getElementById("playerBadge").textContent = "Player: " + (getPlayerName() || "(not set)");
  document.getElementById("gameBadge").textContent = "Game: " + getGameId();
  document.getElementById("turnBadge").textContent = "Turn: " + (uiState.turn ?? 1);
  document.getElementById("waveBadge").textContent =
  "Wave: " + (uiState.wave ?? 0) + " | Left: " + (uiState.waveMobsLeft ?? 0);
  document.getElementById("partyCount").textContent = "Players: " + (uiState.party?.length ?? 0);
} // (END renderBadges)

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
} // (END escapeHtml)

function mobImageUrl(mobId){
  if (!mobId) return "";
  const safe = mobId.replace(/[^a-zA-Z0-9_-]/g, "");
  return IMG_BASE + safe + IMG_EXT;
} // (END mobImageUrl)

function playerImageUrl(avatarId){
  if (!avatarId) return "";
  const safe = avatarId.replace(/[^a-zA-Z0-9_-]/g, "");
  return AVATAR_IMG_BASE + safe + IMG_EXT;
} // (END playerImageUrl)
/* ======================================================================
   UI STATE + BASIC HELPERS (END)
   ====================================================================== */


/* ======================================================================
   ENCOUNTER (NO FLICKER) - PERSISTENT DOM (BEGIN)
   ====================================================================== */

/* Create the scene ONCE and reuse it forever */
function ensureScene(){
  const lanesEl = document.getElementById("lanes");
  let scene = lanesEl.querySelector(".scene");
  if (scene) return scene;

  lanesEl.innerHTML = "";

  scene = document.createElement("div");
  scene.className = "scene";

  const battlefield = document.createElement("div");
  battlefield.className = "battlefield";

  const fog1 = document.createElement("div"); fog1.className = "fog";
  const fog2 = document.createElement("div"); fog2.className = "fog f2";

  scene.appendChild(battlefield);
  scene.appendChild(fog1);
  scene.appendChild(fog2);

  lanesEl.appendChild(scene);
  return scene;
} // (END ensureScene)

/* Utility: scale mobs by y (depth illusion) */
function depthScale(y01){
  return 0.55 + clamp01(y01) * 0.55; // far -> small, near -> big
} // (END depthScale)

/* Create one mob DOM node (once per mob id) */
function createMobDom(mobId, idx){
  const scene = ensureScene();
  const battlefield = scene.querySelector(".battlefield");

  const wrap = document.createElement("div");
  wrap.className = "mobAbs";
  wrap.dataset.id = mobId;

  const card = document.createElement("div");
  card.className = "mobCard " + (["t1","t2","t3","t4"][idx % 4]);

  const mobInner = document.createElement("div");
  mobInner.className = "mob";

  const targetTag = document.createElement("div");
  targetTag.className = "targetTag";
  targetTag.textContent = mobId;

  const img = document.createElement("img");
  img.className = "mobImg";
  img.loading = "lazy";

  const avatarFallback = document.createElement("div");
  avatarFallback.className = "avatar";
  avatarFallback.style.display = "none";
  avatarFallback.textContent = mobId.slice(0,3);


  const hpBar = document.createElement("div");
  hpBar.className = "hpBar";

  const hpFill = document.createElement("div");
  hpFill.className = "hpFill";
  hpBar.appendChild(hpFill);

  mobInner.appendChild(targetTag);
  mobInner.appendChild(img);
  mobInner.appendChild(avatarFallback);
  mobInner.appendChild(hpBar);

  card.appendChild(mobInner);
  wrap.appendChild(card);
  battlefield.appendChild(wrap);

  img.onerror = () => {
    img.style.display = "none";
    avatarFallback.style.display = "grid";
  };

  wrap.onclick = () => {
    uiState.selectedMobId = mobId;
    uiState.selectedPartyId = null;

    const m = (uiState.mobs || []).find(x => String(x.id) === String(mobId));
    document.getElementById("actionTarget").value =
      m?.displayName || m?.avatarId || mobId;

    updateEncounterMobs();
  };


  const entry = { wrap, card, img, hpFill, targetTag, avatarFallback };
  mobDom.set(mobId, entry);
  return entry;
} // (END createMobDom)

/* Update / patch mobs in place (no innerHTML reset => no flicker) */
function updateEncounterMobs(){
  const scene = ensureScene();
  const battlefield = scene.querySelector(".battlefield");
  const rect = scene.getBoundingClientRect();
  const w = Math.max(1, rect.width);
  const h = Math.max(1, rect.height);
  const pad = 10;

  const now = Date.now();

  const alive = (uiState.mobs || []).filter(m => Number(m.hp) > 0);

  const corpses = [];
  for (const [id, fx] of deadFx){
    if (fx.untilMs > now && fx.lastMob) corpses.push(fx.lastMob);
  }

  const mobs = [...alive, ...corpses];
  const seen = new Set();

  // draw order: far first, near last
  mobs.sort((a,b) => Number(a.y ?? 0.5) - Number(b.y ?? 0.5));

  for (let i=0; i<mobs.length; i++){
    const m = mobs[i];
    const id = String(m.id ?? "");
    if (!id) continue;

    seen.add(id);

    let entry = mobDom.get(id);
    if (!entry){
      entry = createMobDom(id, i);
    }

    // Compute coords
    const x01 = clamp01(Number(m.x ?? 0.5));
    const y01 = clamp01(Number(m.y ?? 0.5));

    const x = pad + x01 * (w - pad*2);
    const y = pad + y01 * (h - pad*2);

    // Position
    entry.wrap.style.left = `${x}px`;
    entry.wrap.style.top  = `${y}px`;

    // Depth scale
    const s = depthScale(y01);
    entry.wrap.style.transform = `translate3d(-50%, -85%, 0) scale(${s})`;

    // Z-index by y
    entry.wrap.style.zIndex = String(Math.floor(y01 * 1000));

    // HP
    const max = Number(m.max || m.hpMax || 1);
    const hp  = Number(m.hp || 0);
    const hpPct = max > 0 ? clamp01(hp / max) * 100 : 0;
    entry.hpFill.style.width = `${hpPct}%`;

    // Tag + fallback text (keeps correct if id changed – normally it won't)
    const label = String(m.displayName || m.avatarId || id);
    entry.targetTag.textContent = label;                 // shows "Spider"
    entry.avatarFallback.textContent = label.slice(0,3); // shows "Spi"

    // Classes
    const isDead = hp <= 0;
    entry.card.classList.toggle("dead", isDead);

    // Only allow selecting alive mobs (if dead, clear selection if it was selected)
    if (isDead && uiState.selectedMobId === id){
      uiState.selectedMobId = null;
    }

    entry.card.classList.toggle("selected", uiState.selectedMobId === id);

    const threat = (uiState.selectedMobId === id) || (hpPct >= 75);
    entry.card.classList.toggle("threat", threat);

    // Death icon: add/remove only on state change
    let deathIcon = entry.card.querySelector(".deathIcon");
    if (isDead && !deathIcon){
      deathIcon = document.createElement("div");
      deathIcon.className = "deathIcon";
      deathIcon.innerHTML = `<img src="${MEDIA.images.dead}" alt="dead" />`;
      entry.card.appendChild(deathIcon);
    } else if (!isDead && deathIcon){
      deathIcon.remove();
    }

    // Image: only set src if changed (prevents flicker)
    const wantSrc = mobImageUrl(m.avatarId || id);
    if (entry.img.getAttribute("src") !== wantSrc){
      entry.img.style.display = "";
      entry.avatarFallback.style.display = "none";
      entry.img.src = wantSrc;
    }
  }

  // Remove missing mobs
  for (const [id, entry] of mobDom){
    if (!seen.has(id)){
      entry.wrap.remove();
      mobDom.delete(id);
    }
  }
} // (END updateEncounterMobs)
/* ======================================================================
   ENCOUNTER (NO FLICKER) - PERSISTENT DOM (END)
   ====================================================================== */


/* ======================================================================
   PARTY RENDER (BEGIN)
   ====================================================================== */
function barRow(label, percent01, rightText, cls){
  const w = Math.round(percent01 * 100);
  return `
    <div class="pBarRow">
      <div style="font-weight:900;opacity:.9;">${label}</div>
      <div class="pBar ${cls}"><div style="width:${w}%;"></div></div>
      <div style="text-align:right;opacity:.85;">${escapeHtml(rightText)}</div>
    </div>
  `;
} // (END barRow)

function renderParty(){
  const partyEl = document.getElementById("party");
  partyEl.innerHTML = "";

  (uiState.party || []).forEach(p => {
    const row = document.createElement("div");
    row.className = "pRow";

    if (uiState._damagedIds && uiState._damagedIds.has(p.id)){
      row.classList.add("damaged");
    }
    if (uiState.selectedPartyId === p.id){
      row.classList.add("selected");
    }

    const hpP = pct(p.hp, p.hpMax);
    const enP = pct(p.en, p.enMax);
    const mnP = pct(p.mn, p.mnMax);

    const lvl = Number(p.level ?? 0);
    const xp  = Number(p.xp ?? 0);
    const xpMax = getXpMax(p); // can be null
    const xpP = (xpMax && xpMax > 0) ? pct(xp, xpMax) : 0;

    const imgUrl = playerImageUrl(p.avatarId);

    row.innerHTML = `
      <div class="pAvatar">
        <img class="avatarImg"
             src="${escapeHtml(imgUrl)}"
             alt="${escapeHtml(p.id || "")}"
             loading="lazy"
             onerror="this.style.display='none'; this.nextElementSibling.style.display='grid';" />
        <div class="avatarText" style="display:none">
          ${escapeHtml((p.id||"?").slice(0,2).toUpperCase())}
        </div>
      </div>

      <div class="pInfo">
        <div class="pNameLine">
          <span class="name">${escapeHtml(p.id || "")}</span>

          <div style="display:flex; align-items:center; gap:8px;">
            <span class="lvlBadge">Lvl ${escapeHtml(lvl)}</span>
            <span class="meta">${p.active ? "ACTIVE" : ""}</span>
          </div>
        </div>

        <div class="pBars">
            ${barRow("HP", hpP, `${p.hp}/${p.hpMax}`, "hp")}
            ${barRow("EN", enP, `${p.en}/${p.enMax}`, "en")}
            ${barRow("MN", mnP, `${p.mn}/${p.mnMax}`, "mn")}
                        ${
            (xpMax && xpMax > 0)
                ? barRow("XP", xpP, `${xp}/${xpMax}`, "xp")
                : `<div class="pBarRow">
                    <div style="font-weight:900;opacity:.9;">XP</div>
                    <div class="pBar xp"><div style="width:0%;"></div></div>
                    <div style="text-align:right;opacity:.85;">${escapeHtml(String(xp))}</div>
                  </div>`
            }

        </div>
      </div>
    `;

    row.onclick = () => {
      const name = (p.id || "").trim();
      if (!name) return;
      actionTargetEl.value = name;

      uiState.selectedPartyId = p.id;
      uiState.selectedMobId = null;

      // Update selection without recreating encounter DOM
      updateEncounterMobs();
      renderParty();
      renderBadges();
    };

    partyEl.appendChild(row);
  });
} // (END renderParty)
/* ======================================================================
   PARTY RENDER (END)
   ====================================================================== */


/* ======================================================================
   INFO MSG (BEGIN)
   ====================================================================== */
let lastInfoMsg = "";

function updateInfoMarquee(msg){
  const marquee = document.getElementById("infoMarquee");
  const a = document.getElementById("infoTextA");
  if (!marquee || !a) return;

  const text = String(msg || "").trim();
  const shown = text || "—";

  a.textContent = shown;
  marquee.title = text;

  marquee.classList.remove("scrolling");
  marquee.style.removeProperty("--infoShift");
  marquee.style.removeProperty("--infoDur");

  lastInfoMsg = text;
} // (END updateInfoMarquee)
/* ======================================================================
   INFO MSG (END)
   ====================================================================== */


/* ======================================================================
   DAMAGE + DEATH DETECTION (BEGIN)
   ====================================================================== */
function extractPartyMap(state){
  const map = new Map();
  (state?.party || []).forEach(p => map.set(p.id, p));
  return map;
} // (END extractPartyMap)

function detectPartyDamage(prev, next){
  const prevMap = extractPartyMap(prev);
  const out = [];

  for (const p of (next?.party || [])){
    const id = p.id;
    const prevP = prevMap.get(id);
    if (!prevP) continue;

    const oldHp = Number(prevP.hp ?? 0);
    const newHp = Number(p.hp ?? 0);

    if (newHp < oldHp){
      out.push({ id, dmg: oldHp - newHp, newHp, oldHp });
    }
  }

  return out;
} // (END detectPartyDamage)


// begin ShowToast
function showToast(text, type = "info", ms = 1800){
  const host = document.getElementById("lootToastHost");
  if (!host) return;

  const el = document.createElement("div");
  el.className = "lootToast";

  const t = String(type || "info").toLowerCase();

  if (t === "error") el.classList.add("toastError");
  else if (t === "warn" || t === "warning") el.classList.add("toastWarn");
  else if (t === "success") el.classList.add("toastSuccess");
  else el.classList.add("toastInfo");

  el.textContent = String(text || "—");

  // Optional: make animation duration match ms (recommended)
  el.style.animationDuration = `${Math.max(300, ms)}ms`;

  host.appendChild(el);
  setTimeout(() => el.remove(), Math.max(300, ms) + 50);
}// (END showToast)

function showLootToast(text){
  showToast(text, "info", 1800);
} // (END showLootToast)

let lastState = null;
const playedDeaths = new Set();

function extractMobsMap(state){
  const map = new Map();
  (state?.mobs || []).forEach(m => map.set(m.id, m));
  return map;
} // (END extractMobsMap)

function detectMobDeaths(prev, next){
  const prevMap = extractMobsMap(prev);
  const nextMap = extractMobsMap(next);
  const now = Date.now();

  // If mob became alive again, allow FX again
  for (const [id, m] of nextMap) {
    if (Number(m.hp) > 0) {
      playedDeaths.delete(id);
      deadFx.delete(id);
    }
  }

  const triggerDeathFx = (id, mobSnapshot) => {
    if (playedDeaths.has(id)) return;
    playedDeaths.add(id);

    playSound("mobdeath");

    deadFx.set(id, {
      untilMs: now + DEAD_STAY_MS,
      lastMob: { ...mobSnapshot, hp: 0 }
    });

    showLootToast(`${id} is killed!`);
  };

  // Case A: hp dropped to 0
  for (const [id, nextMob] of nextMap){
    const prevMob = prevMap.get(id);
    const wasAlive = prevMob ? (Number(prevMob.hp) > 0) : true;
    const isDead   = Number(nextMob.hp) <= 0;
    if (wasAlive && isDead) triggerDeathFx(id, nextMob);
  }

  // Case B: mob got removed
  for (const [id, prevMob] of prevMap){
    const existsNow = nextMap.has(id);
    const wasAlive  = Number(prevMob.hp) > 0;
    if (wasAlive && !existsNow) triggerDeathFx(id, prevMob);
  }

  // Cleanup old corpse FX
  for (const [id, fx] of deadFx){
    if (now > fx.untilMs) deadFx.delete(id);
  }
} // (END detectMobDeaths)
/* ======================================================================
   DAMAGE + DEATH DETECTION (END)
   ====================================================================== */

  // Help Button handling
  document.getElementById("btnHelp")?.addEventListener("click", () => {
    window.open("help.html", "_blank", "noopener");
  });//end Help button handling


/* ======================================================================
   GAME OVER + HIT FLASH (BEGIN)
   ====================================================================== */
function showGameOverOverlay(reason, restartInMs){
  const overlay = document.getElementById("gameOverOverlay");
  const reasonEl = document.getElementById("gameOverReason");
  const secEl = document.getElementById("gameOverSeconds");
  if (!overlay) return;

  reasonEl.textContent = reason || "You lost";
  const sec = Math.max(0, Math.ceil((Number(restartInMs) || 0) / 1000));
  secEl.textContent = String(sec);

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden", "false");
  document.body.classList.add("locked");
} // (END showGameOverOverlay)

function hideGameOverOverlay(){
  const overlay = document.getElementById("gameOverOverlay");
  if (!overlay) return;

  overlay.classList.add("hidden");
  overlay.setAttribute("aria-hidden", "true");
  document.body.classList.remove("locked");
} // (END hideGameOverOverlay)

let lastHitFlashAt = 0;

function triggerHitFeedback(intensity01 = 0.7){
  if (!ENABLE_HIT_FLASH) return;

  const now = performance.now();
  if (now - lastHitFlashAt < 500) return;
  lastHitFlashAt = now;

  const flash = document.getElementById("hitFlash");
  if (!flash) return;

  flash.classList.remove("on");
  void flash.offsetHeight;
  flash.style.opacity = String(Math.max(0.2, Math.min(0.6, intensity01)));
  flash.classList.add("on");

  if (ENABLE_SHAKE){
    document.body.classList.add("hitShake");
    setTimeout(() => document.body.classList.remove("hitShake"), 260);
  }
} // (END triggerHitFeedback)

function updateFlashBtn(){
  const b = document.getElementById("btnFlash");
  if (!b) return;
  b.textContent = "Flash: " + (ENABLE_HIT_FLASH ? "ON" : "OFF");
} // (END updateFlashBtn)

document.getElementById("btnFlash")?.addEventListener("click", () => {
  ENABLE_HIT_FLASH = !ENABLE_HIT_FLASH;
  localStorage.setItem("enableHitFlash", ENABLE_HIT_FLASH ? "1" : "0");
  updateFlashBtn();
});
updateFlashBtn();
/* ======================================================================
   GAME OVER + HIT FLASH (END)
   ====================================================================== */


/* ======================================================================
   RENDER ALL (BEGIN)
   ====================================================================== */
function renderAll(){
  renderBadges();
  updateEncounterMobs();  // IMPORTANT: patches DOM (no flicker)
  renderParty();
} // (END renderAll)
/* ======================================================================
   RENDER ALL (END)
   ====================================================================== */


/* ======================================================================
   STATE POLLING (BEGIN)
   ====================================================================== */
async function updateState(){
  try{
    const res = await fetch(STATE_URL, { headers: authHeaders(), cache: "no-store" });
    if (res.status === 401) { doLogout(); return; }
    if (!res.ok) return;

    const s = await res.json();

    const meName = getPlayerName();
    const mePlayer = (s.party || []).find(p => String(p.id) === String(meName)) || null;

    updateInfoMarquee(s.infoMsg);

    // Damage feedback: only current player gets effects
    const damages = detectPartyDamage(lastState || uiState, s);
    if (damages.length > 0 && meName){
      const myHit = damages.find(d => d.id === meName);
      if (myHit){
        const intensity = Math.min(0.45, 0.18 + myHit.dmg / 80);
        triggerHitFeedback(intensity);
        playRandomHitSound();

        s._damagedIds = new Set([meName]);
        setTimeout(() => {
          if (uiState && uiState._damagedIds){
            uiState._damagedIds = null;
            renderParty();
          }
        }, 450);
      }
    }

    detectMobDeaths(lastState || uiState, s);

    const keepSelectedMobId   = uiState.selectedMobId;
    const keepSelectedPartyId = uiState.selectedPartyId;

    uiState = s;

    const wasGameOver = String(lastState?.phase || "") === "gameover";
    const isGameOver  = String(s.phase || "") === "gameover";

    if (isGameOver){
      showGameOverOverlay(s.gameOverReason, s.restartInMs);
      if (!wasGameOver) playSound("gameover");
    } else {
      hideGameOverOverlay();
    }

    const wasWave = String(lastState?.phase || "") === "wavecompleted";
    const isWave  = String(s.phase || "") === "wavecompleted";

    // Show wave overlay (only if not gameover)
    if (!isGameOver && isWave){
      // If your server can send nextWaveInTurns or nextWaveInMs, use it.
      // For now we just show "incoming". (You can pass null.)
      showWaveOverlay(s.wave, s.nextWaveInTurns ?? null);

      // one-time success toast when entering wavecompleted
      if (!wasWave && typeof showToast === "function"){
        showToast(`Wave ${Number(s.wave) || 0} cleared!`, "success", 1800);
      }
    } else {
      hideWaveOverlay();
    }

    if (s.selectedMobId == null)   uiState.selectedMobId   = keepSelectedMobId;
    if (s.selectedPartyId == null) uiState.selectedPartyId = keepSelectedPartyId;

    lastState = s;

    // ✅ this must receive the PLAYER OBJECT, not the name
    checkPlayerStatToasts(mePlayer);

    renderAll();
  } catch(e){
    // ignore network errors
  }
} // (END updateState)
/* ======================================================================
   STATE POLLING (END)
   ====================================================================== */

/* ======================================================================
   XP,Level, Credits Toasts (BEGIN)
   ====================================================================== */
// ---------- PLAYER STAT CHANGE TOASTS ----------

let lastPlayerStats = null;   // null = first snapshot (no toasts)

function resetPlayerStatTracking() {
  lastPlayerStats = null;
}

function checkPlayerStatToasts(player) {
  // player is your own player object from JSON state
  // expected fields: credits, level, xp, potions

  if (!player) return;

  // First snapshot → store only, no toasts
  if (lastPlayerStats === null) {
    lastPlayerStats = {
      credits: player.credits ?? 0,
      level:   player.level   ?? 0,
      xp:      player.xp      ?? 0,
      potions: player.potions ?? 0
    };
    return;
  }

  // Helper to compare and toast
  function diff(key, label, positiveMsg, negativeMsg) {
    const prev = lastPlayerStats[key];
    const curr = player[key];

    if (curr === prev) return;

    const delta = curr - prev;

    if (delta > 0) {
      showToast(
        positiveMsg.replace("{n}", Math.abs(delta)),
        "success",
        1500
      );
    } else {
      showToast(
        negativeMsg.replace("{n}", Math.abs(delta)),
        "warning",
        1500
      );
    }

    lastPlayerStats[key] = curr;
  }

  diff(
    "credits",
    "Credits",
    "+{n} Credits",
    "-{n} Credits"
  );

  diff(
    "xp",
    "XP",
    "+{n} XP",
    "-{n} XP"
  );

  diff(
    "potions",
    "Potions",
    "+{n} Potion(s)",
    "-{n} Potion(s)"
  );

  // Level is special → usually only positive
  if (player.level !== lastPlayerStats.level) {
    if (player.level > lastPlayerStats.level) {
      showToast(
        `Level Up! You are now Level ${player.level}`,
        "success",
        2200
      );
    } else {
      showToast(
        `Level changed to ${player.level}`,
        "warning",
        1500
      );
    }
    lastPlayerStats.level = player.level;
  }
}



/* ======================================================================
   XP,Level, Credits Toasts (END)
   ====================================================================== */
/* ======================================================================
   Wave over Functions (BEGIN)
   ====================================================================== */
  function showWaveOverlay(wave, nextInTurns){
    const el = document.getElementById("waveOverlay");
    const title = document.getElementById("waveTitle");
    const sub = document.getElementById("waveSub");
    if (!el || !title || !sub) return;

    title.textContent = `WAVE ${Number(wave) || 0} CLEARED`;
    sub.textContent = (nextInTurns != null)
      ? `Next wave in ~${nextInTurns} turns…`
      : `Next wave incoming…`;

    el.classList.remove("hidden");
    el.setAttribute("aria-hidden", "false");
  }

  function hideWaveOverlay(){
    const el = document.getElementById("waveOverlay");
    if (!el) return;
    el.classList.add("hidden");
    el.setAttribute("aria-hidden", "true");
  }


/* ======================================================================
   Wave over Functions (END)
   ====================================================================== */


/* ======================================================================
   Helper Functions (BEGIN)
   ====================================================================== */

  function getMe(){
    const me = getPlayerName();
    if (!me) return null;
    return (uiState.party || []).find(p => String(p.id) === String(me)) || null;
  } // (END getMe)

  function getResourceValue(player, res){
    if (!player) return 0;
    if (res === "en") return Number(player.en ?? 0);
    if (res === "mn") return Number(player.mn ?? 0);
    return 0;
  } // (END getResourceValue)

  function resLabel(res){
    return res === "en" ? "Energy" : (res === "mn" ? "Mana" : "Resource");
  } // (END resLabel)

  function canPayCost(actionId){
    const rule = ACTION_COSTS[actionId];
    if (!rule || !rule.res || Number(rule.cost) <= 0) return { ok:true };

    const me = getMe();
    const cur = getResourceValue(me, rule.res);
    const need = Number(rule.cost);

    return { ok: cur >= need, res: rule.res, cur, need };
  } // (END canPayCost)

    function getPotionCount(){
    const me = getMe();
    return Number(me?.potions ?? 0);
  } // (END getPotionCount)

  function getXpMax(p){
    // hardcoded at the moment
    return Number(100);
    // prefer explicit max
    if (p && p.xpMax != null) return Number(p.xpMax);

    // alternative naming: "xpToNext" means progress to next level (0..xpToNext)
    if (p && p.xpToNext != null) return Number(p.xpToNext);

    // unknown → no max
    return null;
  }

  function resolveTargetIdFromInput(input){
    const name = String(input || "").trim();
    if (!name) return "";

    // 1) exact id match
    const byId = (uiState.mobs || []).find(m => m.id === name);
    if (byId) return byId.id;

    // 2) match by displayName (first alive match)
    const byName = (uiState.mobs || []).find(
      m => m.displayName === name && Number(m.hp) > 0
    );
    if (byName) return byName.id;

    // 3) fallback: return as-is
    return name;
  }


/* ======================================================================
   KEYBOARD SHORTCUTS (BEGIN)
   ====================================================================== */
const isDesktopInput = window.matchMedia("(pointer: fine)").matches;

document.addEventListener("keydown", (e) => {
  if (!isDesktopInput) return;

  const tag = document.activeElement?.tagName;
  if (tag === "INPUT" || tag === "TEXTAREA") return;

  if (!/^[0-9]$/.test(e.key)) return;

  const index = e.key === "0" ? 9 : (Number(e.key) - 1);
  if (index < 0 || index >= ACTIONS.length) return;

  const actionId = ACTIONS[index].id;
  const btn = document.querySelector(`.action-btn[data-action="${actionId}"]`);
  if (!btn) return;

  e.preventDefault();
  if (btn.classList.contains("cooldown")) return;

  btn.click();
});
/* ======================================================================
   KEYBOARD SHORTCUTS (END)
   ====================================================================== */


/* ======================================================================
   BOOT (BEGIN)
   ====================================================================== */
buildButtons();
setInterval(tickCooldowns, 100);
tickCooldowns();

renderAll();

// Re-position existing mob DOM nodes when resized (no rebuild)
window.addEventListener("resize", () => {
  updateEncounterMobs();
});

setInterval(updateState, 555);
updateState();

window.addEventListener("DOMContentLoaded", () => {
  document.getElementById("btnGameOverLogout")?.addEventListener("click", doLogout);
});
/* ======================================================================
   BOOT (END)
   ====================================================================== */
</script>

<!-- GAME OVER OVERLAY -->
<div id="gameOverOverlay" class="overlay hidden" aria-hidden="true">
  <div class="overlayCard">
    <div class="overlayTitle">YOU LOST</div>
    <div class="overlayReason" id="gameOverReason">All players are dead</div>

    <div class="overlayTimer">
      Restarting in <span id="gameOverSeconds">3</span>s…
    </div>
    <div style="margin-top:16px; display:flex; justify-content:center; gap:12px;">
      <button id="btnGameOverLogout" class="btnTop">Logout</button>
    </div>

    <div class="overlayHint">Get more help!!!</div>
  </div>
</div>


<!-- WAVE OVER OVERLAY -->
<div id="waveOverlay" class="hidden" aria-hidden="true">
  <div class="waveCard">
    <div class="waveTitle" id="waveTitle">WAVE CLEARED</div>
    <div class="waveSub" id="waveSub">Next wave incoming…</div>
  </div>
</div>

</body>
</html>
